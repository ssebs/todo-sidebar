<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src {{cspSource}} 'unsafe-inline'; script-src 'nonce-{{nonce}}' https://cdn.jsdelivr.net;">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kanban Board</title>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <style>
    body {
      padding: 8px;
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      color: var(--vscode-foreground);
      background: var(--vscode-sideBar-background);
    }
    .no-file {
      text-align: center;
      padding: 20px;
      color: var(--vscode-descriptionForeground);
    }
    .board {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .board-header {
      margin-bottom: 8px;
    }
    .board-title {
      font-size: 1.2em;
      font-weight: bold;
      margin: 0 0 4px 0;
    }
    .board-description {
      font-size: 0.9em;
      color: var(--vscode-descriptionForeground);
      margin: 0;
    }
    .column {
      background: var(--vscode-editor-background);
      border: 1px solid var(--vscode-panel-border);
      border-radius: 4px;
      padding: 8px;
    }
    .column-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: bold;
      margin-bottom: 4px;
      padding-bottom: 4px;
      border-bottom: 1px solid var(--vscode-panel-border);
    }
    .column-description {
      font-size: 0.85em;
      color: var(--vscode-descriptionForeground);
      margin: 0 0 8px 0;
      font-weight: normal;
      white-space: pre-wrap;
    }
    .add-task-btn {
      background: none;
      border: none;
      color: var(--vscode-foreground);
      cursor: pointer;
      font-size: 1.2em;
      opacity: 0.5;
      padding: 0 4px;
      line-height: 1;
    }
    .add-task-btn:hover {
      opacity: 1;
    }
    .task-edit-input {
      flex: 1;
      background: var(--vscode-input-background);
      border: 1px solid var(--vscode-focusBorder);
      color: var(--vscode-foreground);
      font-family: inherit;
      font-size: inherit;
      padding: 2px 4px;
      border-radius: 2px;
      min-width: 0;
    }
    .task-edit-input:focus {
      outline: none;
      border-color: var(--vscode-focusBorder);
    }
    .column.drag-over {
      background: var(--vscode-list-hoverBackground);
    }
    .task {
      background: var(--vscode-input-background);
      border: 1px solid var(--vscode-input-border);
      border-radius: 3px;
      padding: 6px 8px;
      margin-bottom: 6px;
      cursor: grab;
    }
    .task:last-child {
      margin-bottom: 0;
    }
    .task.dragging {
      opacity: 0.5;
    }
    .task-header {
      display: flex;
      align-items: flex-start;
      gap: 6px;
    }
    .task-checkbox {
      margin-top: 2px;
      cursor: pointer;
    }
    .task-text {
      flex: 1;
      word-break: break-word;
    }
    .task-text.checked {
      text-decoration: line-through;
      opacity: 0.7;
    }
    .task-actions {
      display: flex;
      flex-shrink: 0;
      gap: 2px;
    }
    .open-btn, .add-subtask-btn {
      background: none;
      border: none;
      color: var(--vscode-textLink-foreground);
      cursor: pointer;
      padding: 2px 4px;
      font-size: 14px;
      line-height: 1;
      opacity: 0.7;
    }
    .open-btn:hover, .add-subtask-btn:hover {
      opacity: 1;
    }
    .children {
      margin-left: 20px;
      margin-top: 4px;
      min-height: 10px;
      font-size: 0.9em;
      color: var(--vscode-descriptionForeground);
    }
    .child-task {
      background: var(--vscode-input-background);
      border: 1px solid var(--vscode-input-border);
      border-radius: 3px;
      padding: 4px 6px;
      margin: 4px 0;
      cursor: grab;
      font-size: 0.9em;
    }
    .child-task .task-header {
      display: flex;
      align-items: flex-start;
      gap: 4px;
    }
    .child-task .task-checkbox {
      margin-top: 1px;
    }
    .child-task .open-btn {
      font-size: 0.8em;
      padding: 1px 3px;
    }
    .child-task.task-ghost {
      opacity: 0.4;
      background: var(--vscode-list-activeSelectionBackground);
      border: 2px dashed var(--vscode-focusBorder);
    }
    /* SortableJS styles */
    .task-ghost {
      opacity: 0.4;
      background: var(--vscode-list-activeSelectionBackground);
      border: 2px dashed var(--vscode-focusBorder);
    }
    .task-chosen {
      background: var(--vscode-list-activeSelectionBackground);
      border-color: var(--vscode-focusBorder);
    }
    .task-drag {
      opacity: 1;
      background: var(--vscode-list-activeSelectionBackground);
    }
    .tasks {
      min-height: 20px;
    }
    .sortable-placeholder {
      height: 40px;
      background: var(--vscode-list-hoverBackground);
      border: 2px dashed var(--vscode-focusBorder);
      border-radius: 3px;
      margin-bottom: 6px;
    }
    /* Column picker modal */
    .column-picker-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .column-picker {
      background: var(--vscode-editor-background);
      border: 1px solid var(--vscode-panel-border);
      border-radius: 6px;
      padding: 12px;
      min-width: 200px;
      max-width: 300px;
    }
    .column-picker-title {
      font-weight: bold;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--vscode-panel-border);
    }
    .column-picker-option {
      display: block;
      width: 100%;
      padding: 8px 12px;
      margin: 4px 0;
      background: var(--vscode-input-background);
      border: 1px solid var(--vscode-input-border);
      border-radius: 3px;
      color: var(--vscode-foreground);
      cursor: pointer;
      text-align: left;
    }
    .column-picker-option:hover {
      background: var(--vscode-list-hoverBackground);
      border-color: var(--vscode-focusBorder);
    }
    .column-picker-cancel {
      display: block;
      width: 100%;
      padding: 8px 12px;
      margin-top: 8px;
      background: transparent;
      border: 1px solid var(--vscode-input-border);
      border-radius: 3px;
      color: var(--vscode-descriptionForeground);
      cursor: pointer;
      text-align: center;
    }
    .column-picker-cancel:hover {
      background: var(--vscode-list-hoverBackground);
    }
    /* Context menu for move to section */
    .context-menu {
      position: fixed;
      background: var(--vscode-menu-background, var(--vscode-editor-background));
      border: 1px solid var(--vscode-menu-border, var(--vscode-panel-border));
      border-radius: 4px;
      padding: 4px 0;
      min-width: 150px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      z-index: 1000;
    }
    .context-menu-item {
      display: block;
      width: 100%;
      padding: 6px 12px;
      background: none;
      border: none;
      color: var(--vscode-menu-foreground, var(--vscode-foreground));
      cursor: pointer;
      text-align: left;
      font-size: inherit;
    }
    .context-menu-item:hover {
      background: var(--vscode-menu-selectionBackground, var(--vscode-list-hoverBackground));
      color: var(--vscode-menu-selectionForeground, var(--vscode-foreground));
    }
    .context-menu-item.disabled {
      opacity: 0.5;
      cursor: default;
    }
    .context-menu-item.disabled:hover {
      background: none;
    }
    .context-menu-separator {
      height: 1px;
      background: var(--vscode-menu-separatorBackground, var(--vscode-panel-border));
      margin: 4px 0;
    }
    .context-menu-header {
      padding: 4px 12px;
      font-size: 0.85em;
      color: var(--vscode-descriptionForeground);
      cursor: default;
    }
  </style>
</head>
<body>
  <div id="content">
    <div class="no-file">
      Open a markdown file to view your todo board.<br>
      Use the command "Todo Sidebar: Open Markdown File"
    </div>
  </div>

  <script nonce="{{nonce}}">
    const vscode = acquireVsCodeApi();
    let board = null;

    function renderChildTask(child, isDoneColumn) {
      const grandchildren = child.children.map(c => renderChildTask(c, isDoneColumn)).join('');
      return `
        <div class="child-task" draggable="true" data-line="${child.line}" data-in-done="${isDoneColumn}">
          <div class="task-header">
            <input type="checkbox" class="task-checkbox" ${child.checked ? 'checked' : ''} data-line="${child.line}" data-in-done="${isDoneColumn}">
            <span class="task-text ${child.checked ? 'checked' : ''}">${escapeHtml(child.text)}</span>
            <div class="task-actions">
              <button class="add-subtask-btn" data-line="${child.line}" title="Add subtask">+</button>
              <button class="open-btn" data-line="${child.line}" title="Open in editor">↗</button>
            </div>
          </div>
          ${grandchildren ? '<div class="children" data-parent-line="' + child.line + '">' + grandchildren + '</div>' : ''}
        </div>
      `;
    }

    function renderTask(task, isDoneColumn = false) {
      const children = task.children.map(child => renderChildTask(child, isDoneColumn)).join('');

      return `
        <div class="task" draggable="true" data-line="${task.line}" data-in-done="${isDoneColumn}">
          <div class="task-header">
            <input type="checkbox" class="task-checkbox" ${task.checked ? 'checked' : ''} data-line="${task.line}" data-in-done="${isDoneColumn}">
            <span class="task-text ${task.checked ? 'checked' : ''}">${escapeHtml(task.text)}</span>
            <div class="task-actions">
              <button class="add-subtask-btn" data-line="${task.line}" title="Add subtask">+</button>
              <button class="open-btn" data-line="${task.line}" title="Open in editor">↗</button>
            </div>
          </div>
          <div class="children" data-parent-line="${task.line}">${children}</div>
        </div>
      `;
    }

    function renderColumn(column) {
      const tasks = column.tasks.map(task => renderTask(task, column.isDoneColumn)).join('');
      const descriptionHtml = column.description ? `<p class="column-description">${escapeHtml(column.description)}</p>` : '';
      return `
        <div class="column" data-section="${escapeHtml(column.title)}" data-is-done="${column.isDoneColumn}">
          <div class="column-header">
            <span class="column-title">${escapeHtml(column.title)}</span>
            <button class="add-task-btn" data-section="${escapeHtml(column.title)}" title="Add task">+</button>
          </div>
          ${descriptionHtml}
          <div class="tasks" data-section="${escapeHtml(column.title)}">${tasks}</div>
        </div>
      `;
    }

    function renderBoard(board) {
      if (!board || !board.columns || board.columns.length === 0) {
        return '<div class="no-file">No columns found in the markdown file.</div>';
      }

      const columns = board.columns.map(col => renderColumn(col)).join('');
      return `
        <div class="board-header">
          ${board.title ? '<h2 class="board-title">' + escapeHtml(board.title) + '</h2>' : ''}
          ${board.description ? '<p class="board-description">' + escapeHtml(board.description) + '</p>' : ''}
        </div>
        <div class="board">${columns}</div>
      `;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function updateUI() {
      document.getElementById('content').innerHTML = renderBoard(board);
      setupEventListeners();
    }

    function showColumnPicker(columns, taskLine) {
      // Filter out the Done column - user shouldn't move back to Done
      const availableColumns = columns.filter(c => !c.isDoneColumn);

      const overlay = document.createElement('div');
      overlay.className = 'column-picker-overlay';
      overlay.innerHTML = `
        <div class="column-picker">
          <div class="column-picker-title">Move task to:</div>
          ${availableColumns.map(c => `
            <button class="column-picker-option" data-column="${escapeHtml(c.title)}">${escapeHtml(c.title)}</button>
          `).join('')}
          <button class="column-picker-cancel">Cancel</button>
        </div>
      `;

      overlay.addEventListener('click', (e) => {
        if (e.target.classList.contains('column-picker-option')) {
          const targetColumn = e.target.dataset.column;
          vscode.postMessage({ type: 'toggle', line: taskLine, checked: false, targetColumn });
          overlay.remove();
        } else if (e.target.classList.contains('column-picker-cancel') || e.target === overlay) {
          // Cancel - revert the checkbox
          const checkbox = document.querySelector(`.task-checkbox[data-line="${taskLine}"]`);
          if (checkbox) checkbox.checked = true;
          overlay.remove();
        }
      });

      document.body.appendChild(overlay);
    }

    function showContextMenu(e, taskLine, currentSection) {
      // Remove any existing context menu
      const existingMenu = document.querySelector('.context-menu');
      if (existingMenu) existingMenu.remove();

      if (!board || !board.columns) return;

      const menu = document.createElement('div');
      menu.className = 'context-menu';

      // Add header
      const header = document.createElement('div');
      header.className = 'context-menu-header';
      header.textContent = 'Move to section';
      menu.appendChild(header);

      // Add separator
      const separator = document.createElement('div');
      separator.className = 'context-menu-separator';
      menu.appendChild(separator);

      // Add column options
      board.columns.forEach(column => {
        const item = document.createElement('button');
        item.className = 'context-menu-item';
        item.textContent = column.title;
        item.dataset.column = column.title;

        // Disable current section
        if (column.title === currentSection) {
          item.classList.add('disabled');
          item.textContent += ' (current)';
        }

        menu.appendChild(item);
      });

      // Position the menu at cursor
      menu.style.left = e.clientX + 'px';
      menu.style.top = e.clientY + 'px';

      document.body.appendChild(menu);

      // Adjust position if menu goes off screen
      const rect = menu.getBoundingClientRect();
      if (rect.right > window.innerWidth) {
        menu.style.left = (window.innerWidth - rect.width - 5) + 'px';
      }
      if (rect.bottom > window.innerHeight) {
        menu.style.top = (window.innerHeight - rect.height - 5) + 'px';
      }

      // Handle menu item clicks
      menu.addEventListener('click', (evt) => {
        const item = evt.target.closest('.context-menu-item');
        if (item && !item.classList.contains('disabled')) {
          const targetColumn = item.dataset.column;
          vscode.postMessage({ type: 'move', taskLine, targetSection: targetColumn, position: 'top' });
          menu.remove();
        }
      });

      // Close menu when clicking outside
      function closeMenu(evt) {
        if (!menu.contains(evt.target)) {
          menu.remove();
          document.removeEventListener('click', closeMenu);
          document.removeEventListener('contextmenu', closeMenu);
        }
      }

      // Delay adding the listener to avoid immediate close
      setTimeout(() => {
        document.addEventListener('click', closeMenu);
        document.addEventListener('contextmenu', closeMenu);
      }, 0);
    }

    function enterEditMode(taskElement) {
      const textSpan = taskElement.querySelector('.task-text');
      if (!textSpan || taskElement.querySelector('.task-edit-input')) {
        return; // Already in edit mode
      }

      const line = parseInt(taskElement.dataset.line);
      const originalText = textSpan.textContent;

      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'task-edit-input';
      input.value = originalText;
      input.dataset.line = line;
      input.dataset.originalText = originalText;

      textSpan.replaceWith(input);
      input.focus();
      input.select();

      input.addEventListener('keydown', handleEditKeydown);
      input.addEventListener('blur', handleEditBlur);
    }

    function handleEditKeydown(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        saveEdit(e.target);
      } else if (e.key === 'Escape') {
        e.preventDefault();
        cancelEdit(e.target);
      }
    }

    function handleEditBlur(e) {
      // Small delay to allow cancel via Escape
      setTimeout(() => {
        if (document.body.contains(e.target)) {
          saveEdit(e.target);
        }
      }, 0);
    }

    function saveEdit(input) {
      const line = parseInt(input.dataset.line);
      const newText = input.value.trim();
      const originalText = input.dataset.originalText;

      if (newText && newText !== originalText) {
        vscode.postMessage({ type: 'editTaskText', line, newText });
      }
      // Restore span (UI will fully refresh from file watcher)
      restoreTextSpan(input, newText || originalText);
    }

    function cancelEdit(input) {
      const originalText = input.dataset.originalText;
      restoreTextSpan(input, originalText);
    }

    function restoreTextSpan(input, text) {
      const span = document.createElement('span');
      span.className = 'task-text';
      span.textContent = text;
      input.replaceWith(span);
    }

    function setupEventListeners() {
      // Checkboxes
      document.querySelectorAll('.task-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
          const line = parseInt(e.target.dataset.line);
          const checked = e.target.checked;
          const inDone = e.target.dataset.inDone === 'true';

          if (!checked && inDone) {
            // Unchecking in Done column - show column picker
            pendingUncheckLine = line;
            vscode.postMessage({ type: 'getColumns', line });
          } else {
            // Normal toggle
            vscode.postMessage({ type: 'toggle', line, checked });
          }
        });
      });

      // Open buttons
      document.querySelectorAll('.open-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const line = parseInt(e.target.dataset.line);
          vscode.postMessage({ type: 'openAtLine', line });
        });
      });

      // Add task buttons
      document.querySelectorAll('.add-task-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const section = e.target.dataset.section;
          vscode.postMessage({ type: 'addTask', section });
        });
      });

      // Add subtask buttons
      document.querySelectorAll('.add-subtask-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const parentLine = parseInt(e.target.dataset.line);
          vscode.postMessage({ type: 'addSubtask', parentLine });
        });
      });

      // Double-click to edit - listen on task container, not just text
      document.querySelectorAll('.task, .child-task').forEach(taskElement => {
        taskElement.addEventListener('dblclick', (e) => {
          // Don't trigger if clicking on buttons or checkbox
          if (e.target.closest('button, input')) {
            return;
          }
          e.stopPropagation();
          enterEditMode(taskElement);
        });
      });

      // Right-click context menu to move to section
      document.querySelectorAll('.task, .child-task').forEach(taskElement => {
        taskElement.addEventListener('contextmenu', (e) => {
          // Don't trigger if clicking on buttons or checkbox
          if (e.target.closest('button, input')) {
            return;
          }
          e.preventDefault();
          e.stopPropagation();

          const taskLine = parseInt(taskElement.dataset.line);
          // Find the current section by walking up to the column
          const column = taskElement.closest('.column');
          const currentSection = column ? column.dataset.section : null;

          showContextMenu(e, taskLine, currentSection);
        });
      });

      // SortableJS for column-level tasks
      document.querySelectorAll('.tasks').forEach(taskList => {
        new Sortable(taskList, {
          group: 'shared',
          animation: 150,
          ghostClass: 'task-ghost',
          chosenClass: 'task-chosen',
          dragClass: 'task-drag',
          onEnd: (evt) => {
            const taskLine = parseInt(evt.item.dataset.line);
            const targetSection = evt.to.dataset.section;
            const targetParentLine = evt.to.dataset.parentLine;
            const newIndex = evt.newIndex;

            if (targetParentLine) {
              // Dropped into a parent task's children area
              const prevSibling = evt.item.previousElementSibling;
              const afterLine = prevSibling ? parseInt(prevSibling.dataset.line) : undefined;
              vscode.postMessage({
                type: 'moveToParent',
                taskLine,
                parentLine: parseInt(targetParentLine),
                position: newIndex === 0 ? 'top' : 'after',
                afterLine
              });
            } else if (targetSection) {
              // Dropped into a column - find what we're after
              const prevSibling = evt.item.previousElementSibling;
              if (newIndex === 0 || !prevSibling) {
                vscode.postMessage({ type: 'move', taskLine, targetSection, position: 'top' });
              } else {
                const afterLine = parseInt(prevSibling.dataset.line);
                vscode.postMessage({ type: 'move', taskLine, targetSection, position: 'after', afterLine });
              }
            }
          }
        });
      });

      // SortableJS for child tasks within parent tasks
      document.querySelectorAll('.children').forEach(childList => {
        new Sortable(childList, {
          group: 'shared',
          animation: 150,
          ghostClass: 'task-ghost',
          chosenClass: 'task-chosen',
          dragClass: 'task-drag',
          onEnd: (evt) => {
            const taskLine = parseInt(evt.item.dataset.line);
            const targetSection = evt.to.dataset.section;
            const targetParentLine = evt.to.dataset.parentLine;
            const newIndex = evt.newIndex;

            if (targetParentLine) {
              // Dropped into a parent task's children area
              const prevSibling = evt.item.previousElementSibling;
              const afterLine = prevSibling ? parseInt(prevSibling.dataset.line) : undefined;
              vscode.postMessage({
                type: 'moveToParent',
                taskLine,
                parentLine: parseInt(targetParentLine),
                position: newIndex === 0 ? 'top' : 'after',
                afterLine
              });
            } else if (targetSection) {
              // Promoted to column level (dragged out of parent)
              const prevSibling = evt.item.previousElementSibling;
              if (newIndex === 0 || !prevSibling) {
                vscode.postMessage({ type: 'move', taskLine, targetSection, position: 'top' });
              } else {
                const afterLine = parseInt(prevSibling.dataset.line);
                vscode.postMessage({ type: 'move', taskLine, targetSection, position: 'after', afterLine });
              }
            }
          }
        });
      });
    }

    // Handle messages from extension
    window.addEventListener('message', (event) => {
      const message = event.data;
      if (message.type === 'update') {
        board = message.board;
        updateUI();
        // Enter edit mode on newly added task if specified
        if (message.editLine) {
          const taskElement = document.querySelector(`[data-line="${message.editLine}"]`);
          if (taskElement) {
            enterEditMode(taskElement);
          }
        }
      } else if (message.type === 'columnsForPicker') {
        showColumnPicker(message.columns, message.taskLine);
      }
    });

    // Keyboard shortcuts for undo/redo
    document.addEventListener('keydown', (e) => {
      // Skip if user is editing a task
      if (document.activeElement && document.activeElement.classList.contains('task-edit-input')) {
        return;
      }

      if (e.ctrlKey || e.metaKey) {
        if (e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          vscode.postMessage({ type: 'undo' });
        } else if (e.key === 'y' || (e.key === 'z' && e.shiftKey)) {
          e.preventDefault();
          vscode.postMessage({ type: 'redo' });
        }
      }
    });
  </script>
</body>
</html>
