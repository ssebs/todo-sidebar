{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://todo-sidebar-md/./src/extension.ts","webpack://todo-sidebar-md/./src/parser.ts","webpack://todo-sidebar-md/external commonjs \"vscode\"","webpack://todo-sidebar-md/./src/serializer.ts","webpack://todo-sidebar-md/external node-commonjs \"fs\"","webpack://todo-sidebar-md/./src/KanbanViewProvider.ts","webpack://todo-sidebar-md/external node-commonjs \"path\"","webpack://todo-sidebar-md/webpack/bootstrap","webpack://todo-sidebar-md/webpack/startup"],"sourcesContent":["import * as vscode from 'vscode';\nimport { KanbanViewProvider } from './KanbanViewProvider';\n\nlet kanbanProvider: KanbanViewProvider;\n\nexport function activate(context: vscode.ExtensionContext) {\n\tconsole.log('Todo Sidebar extension is now active!');\n\n\t// Create and register the webview provider\n\tkanbanProvider = new KanbanViewProvider(context);\n\tcontext.subscriptions.push(\n\t\tvscode.window.registerWebviewViewProvider(\n\t\t\tKanbanViewProvider.viewType,\n\t\t\tkanbanProvider\n\t\t)\n\t);\n\n\t// Register open file command\n\tconst openFileCommand = vscode.commands.registerCommand('todoSidebar.openFile', async () => {\n\t\tconst fileUri = await vscode.window.showOpenDialog({\n\t\t\tcanSelectFiles: true,\n\t\t\tcanSelectFolders: false,\n\t\t\tcanSelectMany: false,\n\t\t\tfilters: {\n\t\t\t\t'Markdown': ['md']\n\t\t\t},\n\t\t\ttitle: 'Select a Markdown file for the Todo Board'\n\t\t});\n\n\t\tif (fileUri && fileUri[0]) {\n\t\t\tawait kanbanProvider.setActiveFile(fileUri[0]);\n\t\t\tvscode.window.showInformationMessage(`Loaded: ${fileUri[0].fsPath}`);\n\t\t}\n\t});\n\n\t// Register refresh command\n\tconst refreshCommand = vscode.commands.registerCommand('todoSidebar.refresh', async () => {\n\t\tawait kanbanProvider.refresh();\n\t});\n\n\tcontext.subscriptions.push(openFileCommand, refreshCommand);\n}\n\nexport function deactivate() {\n\tif (kanbanProvider) {\n\t\tkanbanProvider.dispose();\n\t}\n}\n","export interface Task {\n  text: string;\n  checked: boolean;\n  line: number;\n  children: Task[];\n  hasCheckbox: boolean;\n}\n\nexport interface Column {\n  title: string;\n  description: string;\n  line: number;\n  isDoneColumn: boolean;\n  tasks: Task[];\n}\n\nexport interface Board {\n  title: string;\n  description: string;\n  columns: Column[];\n}\n\n// Regex constants for parsing markdown patterns\nconst TITLE_REGEX = /^#\\s+([^#].*)$/;\nconst DESCRIPTION_REGEX = /^>\\s*(.*)$/;\nconst COLUMN_HEADER_REGEX = /^##\\s+(.+)$/;\nconst MD_TASK_REGEX = /^(\\s*)[-*]\\s+\\[([ xX])\\]\\s+(.+)$/;\nconst UNICODE_TASK_REGEX = /^(\\s*)[-*]\\s+([☐☑✓✗])\\s+(.+)$/;\nconst NESTED_QUOTE_REGEX = /^(\\s*)[-*]\\s+>\\s*(.+)$/;\nconst BULLET_REGEX = /^(\\s+)[-*]\\s+(.+)$/;\nconst CHECKBOX_PREFIX_REGEX = /^\\[[ xX]\\]|^[☐☑✓✗]/;\n\nexport function parseMarkdown(content: string): Board {\n  // Normalize line endings (handle Windows \\r\\n and Mac \\r)\n  const normalizedContent = content.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n  const lines = normalizedContent.split('\\n');\n  const board: Board = {\n    title: '',\n    description: '',\n    columns: []\n  };\n\n  let currentColumn: Column | null = null;\n  let taskStack: { task: Task; indent: number }[] = [];\n  let foundFirstColumn = false;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const lineNumber = i + 1; // 1-indexed for editor navigation\n\n    // Board title: # Title (only before first column)\n    if (!foundFirstColumn) {\n      const titleMatch = line.match(TITLE_REGEX);\n      if (titleMatch) {\n        board.title = titleMatch[1].trim();\n        continue;\n      }\n\n      // Description: > text (only before first column, not indented)\n      const descMatch = line.match(DESCRIPTION_REGEX);\n      if (descMatch) {\n        if (board.description) {\n          board.description += '\\n' + descMatch[1];\n        } else {\n          board.description = descMatch[1];\n        }\n        continue;\n      }\n    }\n\n    // Column header: ## Section\n    const columnMatch = line.match(COLUMN_HEADER_REGEX);\n    if (columnMatch) {\n      foundFirstColumn = true;\n      const title = columnMatch[1].trim();\n      currentColumn = {\n        title,\n        description: '',\n        line: lineNumber,\n        isDoneColumn: title.toLowerCase().includes('done'),\n        tasks: []\n      };\n      board.columns.push(currentColumn);\n      taskStack = [];\n      continue;\n    }\n\n    // Column description: > text (after column header, before any tasks)\n    if (currentColumn && currentColumn.tasks.length === 0) {\n      const descMatch = line.match(DESCRIPTION_REGEX);\n      if (descMatch) {\n        if (currentColumn.description) {\n          currentColumn.description += '\\n' + descMatch[1];\n        } else {\n          currentColumn.description = descMatch[1];\n        }\n        continue;\n      }\n    }\n\n    // Task with markdown checkbox: - [ ] or - [x] or * [ ] or * [x]\n    const taskMatch = line.match(MD_TASK_REGEX);\n    if (taskMatch && currentColumn) {\n      const indent = taskMatch[1].length;\n      const checked = taskMatch[2].toLowerCase() === 'x';\n      const text = taskMatch[3].trim();\n\n      const task: Task = {\n        text,\n        checked,\n        line: lineNumber,\n        children: [],\n        hasCheckbox: true\n      };\n\n      // Find parent based on indentation\n      while (taskStack.length > 0 && taskStack[taskStack.length - 1].indent >= indent) {\n        taskStack.pop();\n      }\n\n      if (taskStack.length > 0) {\n        // Add as child to parent\n        taskStack[taskStack.length - 1].task.children.push(task);\n      } else {\n        // Add as top-level task\n        currentColumn.tasks.push(task);\n      }\n\n      taskStack.push({ task, indent });\n      continue;\n    }\n\n    // Task with unicode checkbox: * ☐ or * ☑ or - ☐ or - ☑\n    const unicodeTaskMatch = line.match(UNICODE_TASK_REGEX);\n    if (unicodeTaskMatch && currentColumn) {\n      const indent = unicodeTaskMatch[1].length;\n      const checkChar = unicodeTaskMatch[2];\n      const checked = checkChar === '☑' || checkChar === '✓';\n      const text = unicodeTaskMatch[3].trim();\n\n      const task: Task = {\n        text,\n        checked,\n        line: lineNumber,\n        children: [],\n        hasCheckbox: true\n      };\n\n      while (taskStack.length > 0 && taskStack[taskStack.length - 1].indent >= indent) {\n        taskStack.pop();\n      }\n\n      if (taskStack.length > 0) {\n        taskStack[taskStack.length - 1].task.children.push(task);\n      } else {\n        currentColumn.tasks.push(task);\n      }\n\n      taskStack.push({ task, indent });\n      continue;\n    }\n\n    // Nested item with > prefix (like \"  * > really good\")\n    const nestedQuoteMatch = line.match(NESTED_QUOTE_REGEX);\n    if (nestedQuoteMatch && taskStack.length > 0) {\n      const text = nestedQuoteMatch[2].trim();\n\n      const childTask: Task = {\n        text,\n        checked: false,\n        line: lineNumber,\n        children: [],\n        hasCheckbox: false\n      };\n\n      // Add to most recent task\n      taskStack[taskStack.length - 1].task.children.push(childTask);\n      continue;\n    }\n\n    // Nested bullet point: - item or * item (without checkbox, indented)\n    const bulletMatch = line.match(BULLET_REGEX);\n    if (bulletMatch && taskStack.length > 0) {\n      const indent = bulletMatch[1].length;\n      const text = bulletMatch[2].trim();\n\n      // Skip if it looks like a checkbox we didn't match\n      if (text.match(CHECKBOX_PREFIX_REGEX)) {\n        continue;\n      }\n\n      const childTask: Task = {\n        text,\n        checked: false,\n        line: lineNumber,\n        children: [],\n        hasCheckbox: false\n      };\n\n      // Find appropriate parent based on indentation\n      while (taskStack.length > 1 && taskStack[taskStack.length - 1].indent >= indent) {\n        taskStack.pop();\n      }\n\n      if (taskStack.length > 0) {\n        taskStack[taskStack.length - 1].task.children.push(childTask);\n      }\n    }\n  }\n\n  return board;\n}\n","module.exports = require(\"vscode\");","// Regex constants for checkbox and indentation patterns\nconst INDENT_REGEX = /^(\\s*)/;\nconst MD_CHECKBOX_UNCHECKED_REGEX = /([-*]\\s+)\\[ \\]/;\nconst MD_CHECKBOX_CHECKED_REGEX = /([-*]\\s+)\\[[xX]\\]/;\nconst UNICODE_CHECKBOX_UNCHECKED_REGEX = /([-*]\\s+)☐/;\nconst UNICODE_CHECKBOX_CHECKED_REGEX = /([-*]\\s+)[☑✓]/;\nconst TASK_WITH_MD_CHECKBOX_REGEX = /^\\s*[-*]\\s+(\\[[ xX]\\]|[☐☑✓✗])?\\s*(.+)$/;\nconst TASK_TEXT_MD_CHECKBOX_REGEX = /^(\\s*[-*]\\s+\\[[ xX]\\]\\s+)(.+)$/;\nconst TASK_TEXT_UNICODE_CHECKBOX_REGEX = /^(\\s*[-*]\\s+[☐☑✓✗]\\s+)(.+)$/;\nconst SECTION_HEADER_REGEX = /^##\\s+(.+)$/;\n\n/**\n * Helper function to parse content into lines while preserving line ending style\n */\nfunction parseContentLines(content: string): { lines: string[]; lineEnding: string } {\n  const lineEnding = content.includes('\\r\\n') ? '\\r\\n' : '\\n';\n  const lines = content.split(/\\r?\\n/);\n  return { lines, lineEnding };\n}\n\nexport function toggleTaskInContent(content: string, line: number, checked: boolean): string {\n  const { lines, lineEnding } = parseContentLines(content);\n  const lineIndex = line - 1; // Convert to 0-indexed\n\n  if (lineIndex >= 0 && lineIndex < lines.length) {\n    const currentLine = lines[lineIndex];\n    if (checked) {\n      // Handle markdown checkboxes: - [ ] or * [ ]\n      let newLine = currentLine.replace(MD_CHECKBOX_UNCHECKED_REGEX, '$1[x]');\n      // Handle unicode checkboxes: ☐ -> ☑\n      newLine = newLine.replace(UNICODE_CHECKBOX_UNCHECKED_REGEX, '$1☑');\n      lines[lineIndex] = newLine;\n    } else {\n      // Handle markdown checkboxes: - [x] or * [x]\n      let newLine = currentLine.replace(MD_CHECKBOX_CHECKED_REGEX, '$1[ ]');\n      // Handle unicode checkboxes: ☑ or ✓ -> ☐\n      newLine = newLine.replace(UNICODE_CHECKBOX_CHECKED_REGEX, '$1☐');\n      lines[lineIndex] = newLine;\n    }\n  }\n\n  return lines.join(lineEnding);\n}\n\nexport function moveTaskInContent(\n  content: string,\n  taskLine: number,\n  targetSectionTitle: string,\n  position: 'top' | 'bottom' | 'after' = 'bottom',\n  afterLine?: number\n): string {\n  const { lines, lineEnding } = parseContentLines(content);\n  const lineIndex = taskLine - 1;\n\n  // Find the task and all its children (indented lines below it)\n  const taskLines: string[] = [];\n  const taskIndent = lines[lineIndex]?.match(INDENT_REGEX)?.[1].length ?? 0;\n\n  // Add the task line\n  taskLines.push(lines[lineIndex]);\n\n  // Add all children (lines with greater indentation following the task)\n  let i = lineIndex + 1;\n  while (i < lines.length) {\n    const currentLine = lines[i];\n    const currentIndent = currentLine.match(INDENT_REGEX)?.[1].length ?? 0;\n\n    // Empty line or line with content at same/less indentation ends the block\n    if (currentLine.trim() === '') {\n      break;\n    }\n    if (currentIndent <= taskIndent && currentLine.trim() !== '') {\n      break;\n    }\n\n    taskLines.push(currentLine);\n    i++;\n  }\n\n  // De-indent the task block to become top-level\n  const deindentedLines = taskLines.map(line => {\n    if (line.startsWith(' '.repeat(taskIndent))) {\n      return line.slice(taskIndent);\n    }\n    return line;\n  });\n\n  // Remove the task block from original position\n  const beforeTask = lines.slice(0, lineIndex);\n  const afterTask = lines.slice(lineIndex + taskLines.length);\n  const newLines = [...beforeTask, ...afterTask];\n\n  // Find the target section and insert position\n  let targetInsertIndex = -1;\n\n  // If position is 'after', we need to find the line to insert after\n  // The afterLine was given in original line numbers, but we need to adjust for removed lines\n  let adjustedAfterLine = afterLine;\n  if (afterLine !== undefined && taskLine < afterLine) {\n    // Task was removed from before afterLine, so adjust\n    adjustedAfterLine = afterLine - taskLines.length;\n  }\n\n  for (let j = 0; j < newLines.length; j++) {\n    const sectionMatch = newLines[j].match(SECTION_HEADER_REGEX);\n    if (sectionMatch) {\n      const sectionTitle = sectionMatch[1].trim();\n      if (sectionTitle === targetSectionTitle || sectionTitle.startsWith(targetSectionTitle)) {\n        if (position === 'top') {\n          // Insert right after the section header (skip empty lines)\n          let insertAfterHeader = j + 1;\n          while (insertAfterHeader < newLines.length && newLines[insertAfterHeader].trim() === '') {\n            insertAfterHeader++;\n          }\n          targetInsertIndex = insertAfterHeader;\n        } else if (position === 'after' && adjustedAfterLine !== undefined) {\n          // Find the task at adjustedAfterLine and insert after it and its children\n          const afterIndex = adjustedAfterLine - 1; // Convert to 0-indexed\n          if (afterIndex >= 0 && afterIndex < newLines.length) {\n            const afterTaskIndent = newLines[afterIndex]?.match(INDENT_REGEX)?.[1].length ?? 0;\n            let insertAfter = afterIndex + 1;\n            // Skip over children of the after task\n            while (insertAfter < newLines.length) {\n              const currentLine = newLines[insertAfter];\n              const currentIndent = currentLine.match(INDENT_REGEX)?.[1].length ?? 0;\n              if (currentLine.trim() === '' || currentIndent <= afterTaskIndent) {\n                break;\n              }\n              insertAfter++;\n            }\n            targetInsertIndex = insertAfter;\n          }\n        } else {\n          // 'bottom' - Find the end of this section\n          let endOfSection = j + 1;\n          while (endOfSection < newLines.length) {\n            if (newLines[endOfSection].match(SECTION_HEADER_REGEX)) {\n              break;\n            }\n            endOfSection++;\n          }\n          targetInsertIndex = endOfSection;\n        }\n        break;\n      }\n    }\n  }\n\n  if (targetInsertIndex === -1) {\n    // Target section not found, return unchanged\n    return content;\n  }\n\n  // Insert task lines at the target position\n  const result = [\n    ...newLines.slice(0, targetInsertIndex),\n    ...deindentedLines,\n    '',\n    ...newLines.slice(targetInsertIndex)\n  ];\n\n  // Clean up multiple consecutive empty lines\n  const cleaned: string[] = [];\n  let lastWasEmpty = false;\n  for (const resultLine of result) {\n    const isEmpty = resultLine.trim() === '';\n    if (isEmpty && lastWasEmpty) {\n      continue;\n    }\n    cleaned.push(resultLine);\n    lastWasEmpty = isEmpty;\n  }\n\n  return cleaned.join(lineEnding);\n}\n\n/**\n * Helper function to check if a line is a descendant of another line\n */\nfunction isDescendantOf(lines: string[], descendantLine: number, ancestorLine: number): boolean {\n  const ancestorIndex = ancestorLine - 1;\n  const descendantIndex = descendantLine - 1;\n\n  if (ancestorIndex < 0 || ancestorIndex >= lines.length) {\n    return false;\n  }\n  if (descendantIndex < 0 || descendantIndex >= lines.length) {\n    return false;\n  }\n\n  // Get the ancestor's indentation\n  const ancestorIndent = lines[ancestorIndex]?.match(INDENT_REGEX)?.[1].length ?? 0;\n\n  // Check all lines after the ancestor until we find a line at same or lower indentation\n  let i = ancestorIndex + 1;\n  while (i < lines.length) {\n    const currentLine = lines[i];\n    const currentIndent = currentLine.match(INDENT_REGEX)?.[1].length ?? 0;\n\n    // If we hit a line at same/lower indentation, we've left the ancestor's descendants\n    if (currentLine.trim() !== '' && currentIndent <= ancestorIndent) {\n      break;\n    }\n\n    // If we found the descendant line, it's a descendant of ancestor\n    if (i === descendantIndex) {\n      return true;\n    }\n\n    i++;\n  }\n\n  return false;\n}\n\nexport function moveTaskToParent(\n  content: string,\n  taskLine: number,\n  parentLine: number,\n  position: 'top' | 'bottom' | 'after' = 'bottom',\n  afterLine?: number\n): string {\n  const { lines, lineEnding } = parseContentLines(content);\n  const taskIndex = taskLine - 1;\n  const parentIndex = parentLine - 1;\n\n  // Prevent moving a task into itself\n  if (taskLine === parentLine) {\n    return content;\n  }\n\n  // Prevent creating circular references (moving a parent into its own descendant)\n  if (isDescendantOf(lines, parentLine, taskLine)) {\n    return content;\n  }\n\n  // Get the task line content\n  const taskContent = lines[taskIndex];\n  if (!taskContent) {\n    return content;\n  }\n\n  // Extract task text (remove leading whitespace, bullet, and checkbox)\n  const taskMatch = taskContent.match(TASK_WITH_MD_CHECKBOX_REGEX);\n  if (!taskMatch) {\n    return content;\n  }\n  const checkboxPart = taskMatch[1] || '[ ]';\n  const taskText = taskMatch[2];\n\n  // Get the parent's indentation level\n  const parentContent = lines[parentIndex];\n  if (!parentContent) {\n    return content;\n  }\n  const parentIndent = parentContent.match(INDENT_REGEX)?.[1].length ?? 0;\n  const childIndent = ' '.repeat(parentIndent + 2);\n\n  // Find all children of the task being moved (to move them too)\n  const taskLines: string[] = [];\n  const originalTaskIndent = taskContent.match(INDENT_REGEX)?.[1].length ?? 0;\n\n  // The task itself, re-indented as a child\n  taskLines.push(`${childIndent}- ${checkboxPart} ${taskText}`);\n\n  // Find and re-indent any children of the moved task\n  let i = taskIndex + 1;\n  while (i < lines.length) {\n    const currentLine = lines[i];\n    const currentIndent = currentLine.match(INDENT_REGEX)?.[1].length ?? 0;\n\n    if (currentLine.trim() === '') {\n      break;\n    }\n    if (currentIndent <= originalTaskIndent && currentLine.trim() !== '') {\n      break;\n    }\n\n    // Re-indent the child line\n    const childMatch = currentLine.match(/^(\\s*)(.+)$/);\n    if (childMatch) {\n      const relativeIndent = currentIndent - originalTaskIndent;\n      const newIndent = ' '.repeat(parentIndent + 2 + relativeIndent);\n      taskLines.push(`${newIndent}${childMatch[2]}`);\n    }\n    i++;\n  }\n\n  // Remove the task (and its children) from original position\n  const originalTaskBlockLength = i - taskIndex;\n\n  // Calculate adjusted parent index after removal\n  let adjustedParentIndex = parentIndex;\n  if (taskIndex < parentIndex) {\n    adjustedParentIndex = parentIndex - originalTaskBlockLength;\n  }\n\n  // Remove task block\n  const beforeTask = lines.slice(0, taskIndex);\n  const afterTask = lines.slice(taskIndex + originalTaskBlockLength);\n  const newLines = [...beforeTask, ...afterTask];\n\n  // Find insertion point - right after the parent or at end of parent's children\n  let insertIndex: number;\n  const adjustedParentContent = newLines[adjustedParentIndex];\n  const adjustedParentIndent = adjustedParentContent?.match(INDENT_REGEX)?.[1].length ?? 0;\n\n  if (position === 'top') {\n    // Insert right after parent line\n    insertIndex = adjustedParentIndex + 1;\n  } else if (position === 'after' && afterLine !== undefined) {\n    // Calculate adjusted afterLine\n    let adjustedAfterLine = afterLine;\n    if (taskIndex < afterLine) {\n      adjustedAfterLine = afterLine - originalTaskBlockLength;\n    }\n    const afterIndex = adjustedAfterLine - 1; // Convert to 0-indexed\n    if (afterIndex >= 0 && afterIndex < newLines.length) {\n      // Find end of the \"after\" task's children\n      const afterTaskIndent = newLines[afterIndex]?.match(INDENT_REGEX)?.[1].length ?? 0;\n      insertIndex = afterIndex + 1;\n      while (insertIndex < newLines.length) {\n        const currentLine = newLines[insertIndex];\n        const currentIndent = currentLine.match(INDENT_REGEX)?.[1].length ?? 0;\n        if (currentLine.trim() === '' || currentIndent <= afterTaskIndent) {\n          break;\n        }\n        insertIndex++;\n      }\n    } else {\n      // Fallback to end of parent's children\n      insertIndex = adjustedParentIndex + 1;\n    }\n  } else {\n    // 'bottom' - Find end of parent's children\n    insertIndex = adjustedParentIndex + 1;\n    while (insertIndex < newLines.length) {\n      const currentLine = newLines[insertIndex];\n      const currentIndent = currentLine.match(INDENT_REGEX)?.[1].length ?? 0;\n\n      if (currentLine.trim() === '') {\n        break;\n      }\n      if (currentIndent <= adjustedParentIndent) {\n        break;\n      }\n      insertIndex++;\n    }\n  }\n\n  // Insert the task lines\n  const result = [\n    ...newLines.slice(0, insertIndex),\n    ...taskLines,\n    ...newLines.slice(insertIndex)\n  ];\n\n  // Clean up multiple consecutive empty lines\n  const cleaned: string[] = [];\n  let lastWasEmpty = false;\n  for (const resultLine of result) {\n    const isEmpty = resultLine.trim() === '';\n    if (isEmpty && lastWasEmpty) {\n      continue;\n    }\n    cleaned.push(resultLine);\n    lastWasEmpty = isEmpty;\n  }\n\n  return cleaned.join(lineEnding);\n}\n\nexport function addTaskToSection(\n  content: string,\n  sectionTitle: string\n): { content: string; line: number } {\n  const { lines, lineEnding } = parseContentLines(content);\n\n  // Find the section header\n  let sectionIndex = -1;\n  for (let i = 0; i < lines.length; i++) {\n    const match = lines[i].match(SECTION_HEADER_REGEX);\n    if (match && match[1].trim() === sectionTitle) {\n      sectionIndex = i;\n      break;\n    }\n  }\n\n  if (sectionIndex === -1) {\n    return { content, line: -1 };\n  }\n\n  // Find insertion point (skip blank lines after header)\n  let insertIndex = sectionIndex + 1;\n  while (insertIndex < lines.length && lines[insertIndex].trim() === '') {\n    insertIndex++;\n  }\n\n  // Insert new task\n  const newTask = '- [ ] New task';\n  lines.splice(insertIndex, 0, newTask);\n\n  return {\n    content: lines.join(lineEnding),\n    line: insertIndex + 1 // 1-indexed\n  };\n}\n\nexport function editTaskTextInContent(\n  content: string,\n  line: number,\n  newText: string\n): string {\n  const { lines, lineEnding } = parseContentLines(content);\n  const lineIndex = line - 1;\n\n  if (lineIndex < 0 || lineIndex >= lines.length) {\n    return content;\n  }\n\n  const currentLine = lines[lineIndex];\n\n  // Match markdown checkbox: - [ ] text or - [x] text\n  const mdMatch = currentLine.match(TASK_TEXT_MD_CHECKBOX_REGEX);\n  if (mdMatch) {\n    lines[lineIndex] = mdMatch[1] + newText;\n    return lines.join(lineEnding);\n  }\n\n  // Match unicode checkbox: - ☐ text or - ☑ text\n  const unicodeMatch = currentLine.match(TASK_TEXT_UNICODE_CHECKBOX_REGEX);\n  if (unicodeMatch) {\n    lines[lineIndex] = unicodeMatch[1] + newText;\n    return lines.join(lineEnding);\n  }\n\n  return content;\n}\n\nexport function addSubtaskToParent(\n  content: string,\n  parentLine: number\n): { content: string; line: number } {\n  const { lines, lineEnding } = parseContentLines(content);\n  const parentIndex = parentLine - 1;\n\n  if (parentIndex < 0 || parentIndex >= lines.length) {\n    return { content, line: -1 };\n  }\n\n  const parentContent = lines[parentIndex];\n  const parentIndent = parentContent.match(INDENT_REGEX)?.[1].length ?? 0;\n  const childIndent = ' '.repeat(parentIndent + 2);\n\n  // Find insertion point: after parent and all its existing children\n  let insertIndex = parentIndex + 1;\n  while (insertIndex < lines.length) {\n    const currentLine = lines[insertIndex];\n    const currentIndent = currentLine.match(INDENT_REGEX)?.[1].length ?? 0;\n\n    if (currentLine.trim() === '') {\n      break;\n    }\n    if (currentIndent <= parentIndent) {\n      break;\n    }\n    insertIndex++;\n  }\n\n  // Insert new subtask\n  const newTask = `${childIndent}- [ ] New task`;\n  lines.splice(insertIndex, 0, newTask);\n\n  return {\n    content: lines.join(lineEnding),\n    line: insertIndex + 1 // 1-indexed\n  };\n}\n\nexport function removeCheckboxFromTask(\n  content: string,\n  line: number\n): string {\n  const { lines, lineEnding } = parseContentLines(content);\n  const lineIndex = line - 1;\n\n  if (lineIndex < 0 || lineIndex >= lines.length) {\n    return content;\n  }\n\n  const currentLine = lines[lineIndex];\n\n  // Match markdown checkbox: - [ ] text or - [x] text and convert to - text\n  const mdMatch = currentLine.match(/^(\\s*[-*]\\s+)\\[[ xX]\\]\\s+(.+)$/);\n  if (mdMatch) {\n    lines[lineIndex] = mdMatch[1] + mdMatch[2];\n    return lines.join(lineEnding);\n  }\n\n  // Match unicode checkbox: - ☐ text or - ☑ text and convert to - text\n  const unicodeMatch = currentLine.match(/^(\\s*[-*]\\s+)[☐☑✓✗]\\s+(.+)$/);\n  if (unicodeMatch) {\n    lines[lineIndex] = unicodeMatch[1] + unicodeMatch[2];\n    return lines.join(lineEnding);\n  }\n\n  return content;\n}\n\nexport function deleteTaskInContent(\n  content: string,\n  taskLine: number\n): string {\n  const { lines, lineEnding } = parseContentLines(content);\n  const lineIndex = taskLine - 1;\n\n  if (lineIndex < 0 || lineIndex >= lines.length) {\n    return content;\n  }\n\n  // Find the task and all its children (indented lines below it)\n  const taskIndent = lines[lineIndex]?.match(INDENT_REGEX)?.[1].length ?? 0;\n\n  // Count lines to remove (task + all children)\n  let linesToRemove = 1;\n  let i = lineIndex + 1;\n  while (i < lines.length) {\n    const currentLine = lines[i];\n    const currentIndent = currentLine.match(INDENT_REGEX)?.[1].length ?? 0;\n\n    // Empty line or line with content at same/less indentation ends the block\n    if (currentLine.trim() === '') {\n      break;\n    }\n    if (currentIndent <= taskIndent && currentLine.trim() !== '') {\n      break;\n    }\n\n    linesToRemove++;\n    i++;\n  }\n\n  // Remove the task block\n  lines.splice(lineIndex, linesToRemove);\n\n  // Clean up multiple consecutive empty lines\n  const cleaned: string[] = [];\n  let lastWasEmpty = false;\n  for (const resultLine of lines) {\n    const isEmpty = resultLine.trim() === '';\n    if (isEmpty && lastWasEmpty) {\n      continue;\n    }\n    cleaned.push(resultLine);\n    lastWasEmpty = isEmpty;\n  }\n\n  return cleaned.join(lineEnding);\n}\n","module.exports = require(\"fs\");","import * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { parseMarkdown, Board, Task, Column } from './parser';\nimport { toggleTaskInContent, moveTaskInContent, moveTaskToParent, addTaskToSection, editTaskTextInContent, addSubtaskToParent, deleteTaskInContent } from './serializer';\n\nexport class KanbanViewProvider implements vscode.WebviewViewProvider {\n  public static readonly viewType = 'todoSidebar.kanbanView';\n\n  private _view?: vscode.WebviewView;\n  private _activeFileUri?: vscode.Uri;\n  private _board?: Board;\n  private _disposables: vscode.Disposable[] = [];\n  private _pendingEditLine?: number;\n\n  // History stack for undo/redo\n  private _historyStack: string[] = [];\n  private _historyIndex: number = -1;\n  private _maxHistorySize: number = 50;\n  private _isUndoRedo: boolean = false;\n\n  // Periodic refresh timer\n  private _periodicRefreshTimer?: NodeJS.Timeout;\n  private _periodicRefreshInterval: number = 5000; // 5 seconds\n\n  constructor(private readonly _context: vscode.ExtensionContext) {}\n\n  public resolveWebviewView(\n    webviewView: vscode.WebviewView,\n    _context: vscode.WebviewViewResolveContext,\n    _token: vscode.CancellationToken\n  ) {\n    this._view = webviewView;\n\n    webviewView.webview.options = {\n      enableScripts: true,\n      localResourceRoots: [this._context.extensionUri]\n    };\n\n    // Don't set HTML here - let _refresh() handle it based on whether activeFile is set\n    // webviewView.webview.html will be set in the restoration logic or _refresh()\n\n    // Handle visibility changes - refresh when panel becomes visible\n    webviewView.onDidChangeVisibility(() => {\n      if (webviewView.visible && this._activeFileUri) {\n        this._refresh();\n        this._startPeriodicRefresh();\n      } else {\n        this._stopPeriodicRefresh();\n      }\n    });\n\n    // Handle messages from webview\n    webviewView.webview.onDidReceiveMessage(async (message) => {\n      switch (message.type) {\n        case 'toggle':\n          await this._handleToggle(message.line, message.checked, message.targetColumn);\n          break;\n        case 'move':\n          await this._handleMove(message.taskLine, message.targetSection, message.position, message.afterLine);\n          break;\n        case 'openAtLine':\n          await this._handleOpenAtLine(message.line);\n          break;\n        case 'getColumns':\n          // Send column list back to webview for the picker\n          if (this._board) {\n            this._view?.webview.postMessage({\n              type: 'columnsForPicker',\n              columns: this._board.columns.map(c => ({ title: c.title, isDoneColumn: c.isDoneColumn })),\n              taskLine: message.line\n            });\n          }\n          break;\n        case 'moveToParent':\n          await this._handleMoveToParent(message.taskLine, message.parentLine, message.position, message.afterLine);\n          break;\n        case 'addTask':\n          await this._handleAddTask(message.section);\n          break;\n        case 'editTaskText':\n          await this._handleEditTaskText(message.line, message.newText);\n          break;\n        case 'addSubtask':\n          await this._handleAddSubtask(message.parentLine);\n          break;\n        case 'undo':\n          await this._handleUndo();\n          break;\n        case 'redo':\n          await this._handleRedo();\n          break;\n        case 'deleteTask':\n          await this._handleDeleteTask(message.line);\n          break;\n        case 'hideSection':\n          await this._handleHideSection(message.sectionTitle);\n          break;\n        case 'selectFile':\n          await this._handleSelectFile();\n          break;\n        case 'saveWizard':\n          await this._handleSaveWizard(message.filePath, message.onDoneAction);\n          break;\n        case 'cancelWizard':\n          await this._handleCancelWizard();\n          break;\n      }\n    });\n\n    // Set up file watchers only once\n    if (this._disposables.length === 0) {\n      this._setupFileWatchers();\n    }\n\n    // Restore file from workspace settings\n    const config = vscode.workspace.getConfiguration('todoSidebar');\n    const savedPath = config.get<string>('activeFile');\n    console.log('Attempting to restore activeFile from settings:', savedPath);\n    if (savedPath) {\n      try {\n        // Support relative paths (e.g., \"./README.md\" or \"docs/todo.md\")\n        if (savedPath.startsWith('./') || savedPath.startsWith('../') || !path.isAbsolute(savedPath)) {\n          const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n          if (workspaceFolder) {\n            this._activeFileUri = vscode.Uri.joinPath(workspaceFolder.uri, savedPath);\n          }\n        } else {\n          this._activeFileUri = vscode.Uri.file(savedPath);\n        }\n        if (this._activeFileUri) {\n          console.log('Restored activeFile:', this._activeFileUri.fsPath);\n        }\n      } catch (e) {\n        console.error('Failed to restore saved file:', e);\n      }\n    }\n\n    // Always refresh when view becomes visible (this will show wizard or board)\n    this._refresh();\n    if (this._activeFileUri) {\n      this._startPeriodicRefresh();\n    }\n  }\n\n  private _startPeriodicRefresh() {\n    // Clear any existing timer\n    this._stopPeriodicRefresh();\n\n    // Only start if view is visible and a file is active\n    if (this._view?.visible && this._activeFileUri) {\n      this._periodicRefreshTimer = setInterval(() => {\n        if (this._view?.visible && this._activeFileUri) {\n          this._refresh();\n        } else {\n          this._stopPeriodicRefresh();\n        }\n      }, this._periodicRefreshInterval);\n    }\n  }\n\n  private _stopPeriodicRefresh() {\n    if (this._periodicRefreshTimer) {\n      clearInterval(this._periodicRefreshTimer);\n      this._periodicRefreshTimer = undefined;\n    }\n  }\n\n  private _setupFileWatchers() {\n    // Watch for text document changes\n    this._disposables.push(\n      vscode.workspace.onDidChangeTextDocument((e) => {\n        if (this._activeFileUri && e.document.uri.toString() === this._activeFileUri.toString()) {\n          this._refresh();\n        }\n      })\n    );\n\n    // Watch for file system changes\n    const watcher = vscode.workspace.createFileSystemWatcher('**/*.md');\n    this._disposables.push(\n      watcher.onDidChange((uri) => {\n        if (this._activeFileUri && uri.toString() === this._activeFileUri.toString()) {\n          this._refresh();\n        }\n      })\n    );\n    this._disposables.push(watcher);\n\n    // Watch for settings.json changes to pick up manual edits to activeFile\n    const settingsWatcher = vscode.workspace.createFileSystemWatcher('**/.vscode/settings.json');\n    this._disposables.push(\n      settingsWatcher.onDidChange(() => {\n        this._reloadActiveFileFromConfig();\n      })\n    );\n    this._disposables.push(settingsWatcher);\n\n    // Also watch for configuration changes (covers both file edits and UI changes)\n    this._disposables.push(\n      vscode.workspace.onDidChangeConfiguration((e) => {\n        if (e.affectsConfiguration('todoSidebar.activeFile')) {\n          this._reloadActiveFileFromConfig();\n        }\n        if (e.affectsConfiguration('todoSidebar.hiddenSections')) {\n          this._refresh();\n        }\n      })\n    );\n  }\n\n  private _reloadActiveFileFromConfig() {\n    const config = vscode.workspace.getConfiguration('todoSidebar');\n    const savedPath = config.get<string>('activeFile');\n    console.log('Config changed, reloading activeFile:', savedPath);\n\n    if (savedPath) {\n      try {\n        // Support relative paths (e.g., \"./README.md\" or \"docs/todo.md\")\n        if (savedPath.startsWith('./') || savedPath.startsWith('../') || !path.isAbsolute(savedPath)) {\n          const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n          if (workspaceFolder) {\n            this._activeFileUri = vscode.Uri.joinPath(workspaceFolder.uri, savedPath);\n          }\n        } else {\n          this._activeFileUri = vscode.Uri.file(savedPath);\n        }\n        if (this._activeFileUri) {\n          console.log('Reloaded activeFile:', this._activeFileUri.fsPath);\n          this._refresh();\n        }\n      } catch (e) {\n        console.error('Failed to reload saved file:', e);\n      }\n    } else {\n      this._activeFileUri = undefined;\n      this._board = undefined;\n      this._view?.webview.postMessage({ type: 'update', board: null });\n    }\n  }\n\n  public async setActiveFile(uri: vscode.Uri) {\n    this._activeFileUri = uri;\n\n    // Clear history when switching files\n    this._historyStack = [];\n    this._historyIndex = -1;\n\n    // Restart periodic refresh with new file\n    this._stopPeriodicRefresh();\n\n    // Store in workspace settings by directly writing to .vscode/settings.json\n    try {\n      const hasWorkspaceFolder = vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0;\n\n      if (!hasWorkspaceFolder) {\n        console.error('No workspace folder open - cannot save to workspace settings');\n        vscode.window.showWarningMessage('Please open a folder/workspace to persist the todo file selection');\n        await this._refresh();\n        return;\n      }\n\n      const workspaceFolder = vscode.workspace.workspaceFolders![0];\n      const vscodeDir = vscode.Uri.joinPath(workspaceFolder.uri, '.vscode');\n      const settingsPath = vscode.Uri.joinPath(vscodeDir, 'settings.json');\n\n      // Ensure .vscode directory exists\n      try {\n        await vscode.workspace.fs.stat(vscodeDir);\n      } catch {\n        await vscode.workspace.fs.createDirectory(vscodeDir);\n        console.log('Created .vscode directory');\n      }\n\n      // Read existing settings content\n      let existingText = '';\n      let fileExists = false;\n      try {\n        const content = await vscode.workspace.fs.readFile(settingsPath);\n        existingText = Buffer.from(content).toString('utf-8');\n        fileExists = true;\n      } catch (e) {\n        // File doesn't exist\n      }\n\n      // Convert to relative path if within workspace\n      let savePath = uri.fsPath;\n      if (workspaceFolder) {\n        const relativePath = path.relative(workspaceFolder.uri.fsPath, uri.fsPath);\n        // Use relative path if it doesn't start with \"..\" (i.e., file is within workspace)\n        if (!relativePath.startsWith('..')) {\n          savePath = './' + relativePath.replace(/\\\\/g, '/');\n        }\n      }\n\n      // Update or insert the setting while preserving existing content\n      const escapedPath = JSON.stringify(savePath);\n      const activeFilePattern = /\"todoSidebar\\.activeFile\"\\s*:\\s*\"[^\"]*\"/;\n      const onDoneActionPattern = /\"todoSidebar\\.onDoneAction\"\\s*:\\s*\"[^\"]*\"/;\n      let newText: string;\n\n      if (!fileExists || existingText.trim() === '') {\n        // Create new settings file with default onDoneAction\n        newText = `{\\n    \"todoSidebar.activeFile\": ${escapedPath},\\n    \"todoSidebar.onDoneAction\": \"move\"\\n}`;\n      } else {\n        // Parse existing file to check for settings\n        const hasActiveFile = activeFilePattern.test(existingText);\n        const hasOnDoneAction = onDoneActionPattern.test(existingText);\n\n        if (hasActiveFile) {\n          // Update existing activeFile setting in place\n          newText = existingText.replace(activeFilePattern, `\"todoSidebar.activeFile\": ${escapedPath}`);\n        } else {\n          // Insert activeFile setting after opening brace\n          const insertMatch = existingText.match(/^\\s*\\{/);\n          if (insertMatch) {\n            const insertPos = insertMatch[0].length;\n            const before = existingText.slice(0, insertPos);\n            const after = existingText.slice(insertPos);\n            const needsComma = after.trim().length > 0 && after.trim() !== '}';\n            const newSetting = `\\n    \"todoSidebar.activeFile\": ${escapedPath}${needsComma ? ',' : ''}`;\n            newText = before + newSetting + after;\n          } else {\n            // Fallback: file is malformed, create new\n            newText = `{\\n    \"todoSidebar.activeFile\": ${escapedPath},\\n    \"todoSidebar.onDoneAction\": \"move\"\\n}`;\n          }\n        }\n\n        // Now check if onDoneAction needs to be added\n        if (!hasOnDoneAction) {\n          // Insert onDoneAction setting after opening brace (or after activeFile if just added)\n          const insertMatch = newText.match(/^\\s*\\{/);\n          if (insertMatch) {\n            const insertPos = insertMatch[0].length;\n            const before = newText.slice(0, insertPos);\n            const after = newText.slice(insertPos);\n            const needsComma = after.trim().length > 0 && after.trim() !== '}';\n            const onDoneSetting = `\\n    \"todoSidebar.onDoneAction\": \"move\"${needsComma ? ',' : ''}`;\n            newText = before + onDoneSetting + after;\n          }\n        }\n      }\n\n      await vscode.workspace.fs.writeFile(settingsPath, Buffer.from(newText, 'utf-8'));\n      console.log('Saved activeFile to .vscode/settings.json:', uri.fsPath);\n\n    } catch (e) {\n      console.error('Failed to save activeFile to settings:', e);\n      vscode.window.showErrorMessage(`Failed to save todo file selection: ${e}`);\n    }\n    await this._refresh();\n    this._startPeriodicRefresh();\n  }\n\n  public async refresh() {\n    await this._refresh();\n  }\n\n  private async _readActiveFile(): Promise<string> {\n    if (!this._activeFileUri) {\n      return '';\n    }\n    const content = await vscode.workspace.fs.readFile(this._activeFileUri);\n    return Buffer.from(content).toString('utf-8');\n  }\n\n  private async _writeActiveFile(text: string): Promise<void> {\n    if (!this._activeFileUri) {\n      return;\n    }\n\n    // Track history for undo/redo (skip if this is an undo/redo operation)\n    if (!this._isUndoRedo) {\n      // If we're not at the end of the stack, truncate forward history\n      if (this._historyIndex < this._historyStack.length - 1) {\n        this._historyStack = this._historyStack.slice(0, this._historyIndex + 1);\n      }\n\n      // Add current state to history\n      this._historyStack.push(text);\n\n      // Limit history size\n      if (this._historyStack.length > this._maxHistorySize) {\n        this._historyStack.shift();\n      } else {\n        this._historyIndex++;\n      }\n    }\n\n    await vscode.workspace.fs.writeFile(this._activeFileUri, Buffer.from(text, 'utf-8'));\n  }\n\n  private async _handleUndo() {\n    if (this._historyIndex <= 0 || !this._activeFileUri) {\n      return;\n    }\n\n    this._historyIndex--;\n    const previousContent = this._historyStack[this._historyIndex];\n\n    this._isUndoRedo = true;\n    try {\n      await vscode.workspace.fs.writeFile(this._activeFileUri, Buffer.from(previousContent, 'utf-8'));\n    } finally {\n      this._isUndoRedo = false;\n    }\n  }\n\n  private async _handleRedo() {\n    if (this._historyIndex >= this._historyStack.length - 1 || !this._activeFileUri) {\n      return;\n    }\n\n    this._historyIndex++;\n    const nextContent = this._historyStack[this._historyIndex];\n\n    this._isUndoRedo = true;\n    try {\n      await vscode.workspace.fs.writeFile(this._activeFileUri, Buffer.from(nextContent, 'utf-8'));\n    } finally {\n      this._isUndoRedo = false;\n    }\n  }\n\n  private async _refresh() {\n    if (!this._view) {\n      return;\n    }\n\n    // Show welcome wizard if no active file\n    if (!this._activeFileUri) {\n      this._view.webview.html = this._getWelcomeHtmlForWebview(this._view.webview);\n      return;\n    }\n\n    // Ensure the webview has the correct HTML template for the board\n    // (needed on first load when restoring from settings)\n    if (!this._view.webview.html.includes('id=\"content\"')) {\n      this._view.webview.html = this._getHtmlForWebview(this._view.webview);\n    }\n\n    try {\n      const text = await this._readActiveFile();\n\n      // Initialize history with first state if empty\n      if (this._historyStack.length === 0) {\n        this._historyStack.push(text);\n        this._historyIndex = 0;\n      }\n\n      this._board = parseMarkdown(text);\n\n      // Filter out hidden sections based on configuration\n      const config = vscode.workspace.getConfiguration('todoSidebar');\n      const hiddenSections = config.get<string[]>('hiddenSections', []);\n\n      const filteredBoard = {\n        ...this._board,\n        columns: this._board.columns.filter(col =>\n          !this._isColumnHidden(col.title, hiddenSections)\n        )\n      };\n\n      const editLine = this._pendingEditLine;\n      this._pendingEditLine = undefined;\n      this._view.webview.postMessage({ type: 'update', board: filteredBoard, editLine });\n    } catch (error) {\n      console.error('Error refreshing kanban board:', error);\n    }\n  }\n\n  private async _handleToggle(line: number, checked: boolean, targetColumn?: string) {\n    if (!this._activeFileUri) {\n      return;\n    }\n\n    try {\n      let text = await this._readActiveFile();\n\n      // Re-parse the board from fresh content to get accurate line numbers\n      const currentBoard = parseMarkdown(text);\n\n      // Only move top-level tasks to Done column (not subtasks)\n      const isTopLevel = this._isTopLevelTaskInBoard(line, currentBoard);\n\n      // Get the onDoneAction configuration\n      const config = vscode.workspace.getConfiguration('todoSidebar');\n      const onDoneAction = config.get<string>('onDoneAction', 'move');\n\n      if (checked && isTopLevel) {\n        // Check configuration for what to do when a task is marked as done\n        if (onDoneAction === 'delete') {\n          // Delete the task and its children immediately without toggling\n          text = deleteTaskInContent(text, line);\n        } else {\n          // Default behavior: toggle checkbox and move to Done column\n          text = toggleTaskInContent(text, line, checked);\n\n          // Move to Done column at TOP\n          const doneColumn = currentBoard.columns.find((c) => c.isDoneColumn);\n          if (doneColumn) {\n            const currentColumn = this._findTaskColumnInBoard(line, currentBoard);\n            if (currentColumn && !currentColumn.isDoneColumn) {\n              text = moveTaskInContent(text, line, doneColumn.title, 'top');\n            }\n          }\n        }\n      } else if (targetColumn && isTopLevel) {\n        // If unchecked and a target column is specified, move there at TOP\n        text = toggleTaskInContent(text, line, checked);\n        text = moveTaskInContent(text, line, targetColumn, 'top');\n      } else {\n        // For non-top-level tasks or other cases, just toggle the checkbox\n        text = toggleTaskInContent(text, line, checked);\n      }\n\n      await this._writeActiveFile(text);\n    } catch (error) {\n      console.error('Error toggling task:', error);\n    }\n  }\n\n  private _isTopLevelTaskInBoard(line: number, board: Board): boolean {\n    for (const column of board.columns) {\n      for (const task of column.tasks) {\n        if (task.line === line) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  private _findTaskColumnInBoard(line: number, board: Board): Column | undefined {\n    const findInTasks = (tasks: Task[]): boolean => {\n      for (const task of tasks) {\n        if (task.line === line) {\n          return true;\n        }\n        if (findInTasks(task.children)) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    for (const column of board.columns) {\n      if (findInTasks(column.tasks)) {\n        return column;\n      }\n    }\n\n    return undefined;\n  }\n\n  private _isColumnHidden(columnTitle: string, hiddenPatterns: string[]): boolean {\n    const lowerTitle = columnTitle.toLowerCase();\n\n    for (const pattern of hiddenPatterns) {\n      const lowerPattern = pattern.toLowerCase();\n\n      // Check if pattern contains regex special characters (besides *)\n      if (/[.+?^${}()|[\\]\\\\]/.test(pattern)) {\n        // Treat as regex pattern\n        try {\n          const regex = new RegExp(pattern, 'i'); // case-insensitive\n          if (regex.test(columnTitle)) {\n            return true;\n          }\n        } catch (e) {\n          // Invalid regex, fall back to exact match\n          if (lowerTitle === lowerPattern) {\n            return true;\n          }\n        }\n      } else if (lowerPattern.includes('*')) {\n        // Simple wildcard pattern: convert * to .*\n        const regexPattern = '^' + lowerPattern.replace(/\\*/g, '.*') + '$';\n        const regex = new RegExp(regexPattern);\n        if (regex.test(lowerTitle)) {\n          return true;\n        }\n      } else {\n        // Exact match (case-insensitive)\n        if (lowerTitle === lowerPattern) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  private async _handleMove(taskLine: number, targetSection: string, position: 'top' | 'bottom' | 'after' = 'bottom', afterLine?: number) {\n    if (!this._activeFileUri) {\n      return;\n    }\n\n    try {\n      let text = await this._readActiveFile();\n      text = moveTaskInContent(text, taskLine, targetSection, position, afterLine);\n      await this._writeActiveFile(text);\n    } catch (error) {\n      console.error('Error moving task:', error);\n    }\n  }\n\n  private async _handleMoveToParent(taskLine: number, parentLine: number, position: 'top' | 'bottom' | 'after' = 'bottom', afterLine?: number) {\n    if (!this._activeFileUri) {\n      return;\n    }\n\n    try {\n      let text = await this._readActiveFile();\n      text = moveTaskToParent(text, taskLine, parentLine, position, afterLine);\n      await this._writeActiveFile(text);\n    } catch (error) {\n      console.error('Error moving task to parent:', error);\n    }\n  }\n\n  private async _handleOpenAtLine(line: number) {\n    if (!this._activeFileUri) {\n      return;\n    }\n\n    try {\n      const document = await vscode.workspace.openTextDocument(this._activeFileUri);\n      const editor = await vscode.window.showTextDocument(document);\n      const position = new vscode.Position(line - 1, 0);\n      editor.selection = new vscode.Selection(position, position);\n      editor.revealRange(new vscode.Range(position, position), vscode.TextEditorRevealType.InCenter);\n    } catch (error) {\n      console.error('Error opening file at line:', error);\n    }\n  }\n\n  private async _handleAddTask(section: string) {\n    if (!this._activeFileUri) {\n      return;\n    }\n\n    try {\n      const text = await this._readActiveFile();\n      const result = addTaskToSection(text, section);\n\n      if (result.line > 0) {\n        this._pendingEditLine = result.line;\n        await this._writeActiveFile(result.content);\n      }\n    } catch (error) {\n      console.error('Error adding task:', error);\n    }\n  }\n\n  private async _handleEditTaskText(line: number, newText: string) {\n    if (!this._activeFileUri) {\n      return;\n    }\n\n    try {\n      let text = await this._readActiveFile();\n      text = editTaskTextInContent(text, line, newText);\n      await this._writeActiveFile(text);\n    } catch (error) {\n      console.error('Error editing task text:', error);\n    }\n  }\n\n  private async _handleAddSubtask(parentLine: number) {\n    if (!this._activeFileUri) {\n      return;\n    }\n\n    try {\n      const text = await this._readActiveFile();\n      const result = addSubtaskToParent(text, parentLine);\n\n      if (result.line > 0) {\n        this._pendingEditLine = result.line;\n        await this._writeActiveFile(result.content);\n      }\n    } catch (error) {\n      console.error('Error adding subtask:', error);\n    }\n  }\n\n  private async _handleDeleteTask(line: number) {\n    if (!this._activeFileUri) {\n      return;\n    }\n\n    try {\n      let text = await this._readActiveFile();\n      text = deleteTaskInContent(text, line);\n      await this._writeActiveFile(text);\n    } catch (error) {\n      console.error('Error deleting task:', error);\n    }\n  }\n\n  private async _handleHideSection(sectionTitle: string) {\n    try {\n      const config = vscode.workspace.getConfiguration('todoSidebar');\n      const hiddenSections = config.get<string[]>('hiddenSections', []);\n\n      // Add the section if it's not already in the list\n      if (!hiddenSections.includes(sectionTitle)) {\n        hiddenSections.push(sectionTitle);\n\n        // Update the configuration in workspace settings\n        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n        if (!workspaceFolder) {\n          vscode.window.showWarningMessage('No workspace folder open - cannot save hidden sections');\n          return;\n        }\n\n        const vscodeDir = vscode.Uri.joinPath(workspaceFolder.uri, '.vscode');\n        const settingsPath = vscode.Uri.joinPath(vscodeDir, 'settings.json');\n\n        // Ensure .vscode directory exists\n        try {\n          await vscode.workspace.fs.stat(vscodeDir);\n        } catch {\n          await vscode.workspace.fs.createDirectory(vscodeDir);\n        }\n\n        // Read existing settings\n        let existingText = '';\n        let fileExists = false;\n        try {\n          const content = await vscode.workspace.fs.readFile(settingsPath);\n          existingText = Buffer.from(content).toString('utf-8');\n          fileExists = true;\n        } catch (e) {\n          // File doesn't exist\n        }\n\n        // Update or insert the hiddenSections setting\n        const escapedArray = JSON.stringify(hiddenSections);\n        const settingPattern = /\"todoSidebar\\.hiddenSections\"\\s*:\\s*\\[[^\\]]*\\]/;\n        let newText: string;\n\n        if (!fileExists || existingText.trim() === '') {\n          // Create new settings file\n          newText = `{\\n    \"todoSidebar.hiddenSections\": ${escapedArray}\\n}`;\n        } else if (settingPattern.test(existingText)) {\n          // Update existing setting\n          newText = existingText.replace(settingPattern, `\"todoSidebar.hiddenSections\": ${escapedArray}`);\n        } else {\n          // Insert new setting after opening brace\n          const insertMatch = existingText.match(/^\\s*\\{/);\n          if (insertMatch) {\n            const insertPos = insertMatch[0].length;\n            const before = existingText.slice(0, insertPos);\n            const after = existingText.slice(insertPos);\n            const needsComma = after.trim().length > 0 && after.trim() !== '}';\n            const newSetting = `\\n    \"todoSidebar.hiddenSections\": ${escapedArray}${needsComma ? ',' : ''}`;\n            newText = before + newSetting + after;\n          } else {\n            // Fallback: file is malformed, create new\n            newText = `{\\n    \"todoSidebar.hiddenSections\": ${escapedArray}\\n}`;\n          }\n        }\n\n        await vscode.workspace.fs.writeFile(settingsPath, Buffer.from(newText, 'utf-8'));\n        console.log('Added section to hiddenSections:', sectionTitle);\n\n        // Show a message to the user\n        vscode.window.showInformationMessage(`Section \"${sectionTitle}\" is now hidden. Edit settings to unhide.`);\n      }\n    } catch (error) {\n      console.error('Error hiding section:', error);\n      vscode.window.showErrorMessage(`Failed to hide section: ${error}`);\n    }\n  }\n\n  private _getHtmlForWebview(webview: vscode.Webview): string {\n    const nonce = getNonce();\n\n    // Read the HTML template file\n    const htmlPath = path.join(this._context.extensionPath, 'src', 'webview.html');\n    let html = fs.readFileSync(htmlPath, 'utf-8');\n\n    // Replace placeholders with actual values\n    html = html.replace(/\\{\\{cspSource\\}\\}/g, webview.cspSource);\n    html = html.replace(/\\{\\{nonce\\}\\}/g, nonce);\n\n    return html;\n  }\n\n  private _getWelcomeHtmlForWebview(webview: vscode.Webview): string {\n    const nonce = getNonce();\n\n    // Read the welcome wizard template\n    const welcomePath = path.join(this._context.extensionPath, 'src', 'welcome.html');\n    let html = fs.readFileSync(welcomePath, 'utf-8');\n\n    // Read the tips content\n    const tipsPath = path.join(this._context.extensionPath, 'src', 'tips.html');\n    const tipsContent = fs.readFileSync(tipsPath, 'utf-8');\n\n    // Replace placeholders\n    html = html.replace(/\\{\\{cspSource\\}\\}/g, webview.cspSource);\n    html = html.replace(/\\{\\{nonce\\}\\}/g, nonce);\n    html = html.replace(/\\{\\{TIPS_CONTENT\\}\\}/g, tipsContent);\n\n    return html;\n  }\n\n  private async _handleSelectFile() {\n    const options: vscode.OpenDialogOptions = {\n      canSelectMany: false,\n      filters: {\n        'Markdown files': ['md', 'markdown']\n      },\n      title: 'Select a markdown file for your todo board'\n    };\n\n    const fileUri = await vscode.window.showOpenDialog(options);\n    if (fileUri && fileUri[0]) {\n      // Send the selected file path back to the webview\n      this._view?.webview.postMessage({\n        type: 'fileSelected',\n        filePath: fileUri[0].fsPath\n      });\n    }\n  }\n\n  private async _handleSaveWizard(filePath: string, onDoneAction: string) {\n    try {\n      // Set the active file\n      const uri = vscode.Uri.file(filePath);\n\n      // Validate the file exists and is readable\n      try {\n        await vscode.workspace.fs.stat(uri);\n      } catch {\n        this._view?.webview.postMessage({\n          type: 'error',\n          message: 'Selected file does not exist or is not accessible'\n        });\n        return;\n      }\n\n      // Save the settings to workspace\n      const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n      if (!workspaceFolder) {\n        vscode.window.showWarningMessage('Please open a folder/workspace to save settings');\n        return;\n      }\n\n      const vscodeDir = vscode.Uri.joinPath(workspaceFolder.uri, '.vscode');\n      const settingsPath = vscode.Uri.joinPath(vscodeDir, 'settings.json');\n\n      // Ensure .vscode directory exists\n      try {\n        await vscode.workspace.fs.stat(vscodeDir);\n      } catch {\n        await vscode.workspace.fs.createDirectory(vscodeDir);\n      }\n\n      // Convert to relative path if within workspace\n      let savePath = filePath;\n      const relativePath = path.relative(workspaceFolder.uri.fsPath, filePath);\n      if (!relativePath.startsWith('..')) {\n        savePath = './' + relativePath.replace(/\\\\/g, '/');\n      }\n\n      // Read existing settings\n      let existingText = '';\n      let fileExists = false;\n      try {\n        const content = await vscode.workspace.fs.readFile(settingsPath);\n        existingText = Buffer.from(content).toString('utf-8');\n        fileExists = true;\n      } catch (e) {\n        // File doesn't exist\n      }\n\n      // Create or update settings\n      const escapedPath = JSON.stringify(savePath);\n      const escapedAction = JSON.stringify(onDoneAction);\n      let newText: string;\n\n      if (!fileExists || existingText.trim() === '') {\n        // Create new settings file\n        newText = `{\\n    \"todoSidebar.activeFile\": ${escapedPath},\\n    \"todoSidebar.onDoneAction\": ${escapedAction}\\n}`;\n      } else {\n        // Update existing settings\n        const activeFilePattern = /\"todoSidebar\\.activeFile\"\\s*:\\s*\"[^\"]*\"/;\n        const onDoneActionPattern = /\"todoSidebar\\.onDoneAction\"\\s*:\\s*\"[^\"]*\"/;\n\n        const hasActiveFile = activeFilePattern.test(existingText);\n        const hasOnDoneAction = onDoneActionPattern.test(existingText);\n\n        newText = existingText;\n\n        if (hasActiveFile) {\n          newText = newText.replace(activeFilePattern, `\"todoSidebar.activeFile\": ${escapedPath}`);\n        } else {\n          // Insert activeFile\n          const insertMatch = newText.match(/^\\s*\\{/);\n          if (insertMatch) {\n            const insertPos = insertMatch[0].length;\n            const before = newText.slice(0, insertPos);\n            const after = newText.slice(insertPos);\n            const needsComma = after.trim().length > 0 && after.trim() !== '}';\n            newText = before + `\\n    \"todoSidebar.activeFile\": ${escapedPath}${needsComma ? ',' : ''}` + after;\n          }\n        }\n\n        if (hasOnDoneAction) {\n          newText = newText.replace(onDoneActionPattern, `\"todoSidebar.onDoneAction\": ${escapedAction}`);\n        } else {\n          // Insert onDoneAction\n          const insertMatch = newText.match(/^\\s*\\{/);\n          if (insertMatch) {\n            const insertPos = insertMatch[0].length;\n            const before = newText.slice(0, insertPos);\n            const after = newText.slice(insertPos);\n            const needsComma = after.trim().length > 0 && after.trim() !== '}';\n            newText = before + `\\n    \"todoSidebar.onDoneAction\": ${escapedAction}${needsComma ? ',' : ''}` + after;\n          }\n        }\n      }\n\n      await vscode.workspace.fs.writeFile(settingsPath, Buffer.from(newText, 'utf-8'));\n\n      // Set the active file and refresh to show the board\n      this._activeFileUri = uri;\n\n      // Clear history when switching files\n      this._historyStack = [];\n      this._historyIndex = -1;\n\n      // Update the webview to show the board\n      this._view!.webview.html = this._getHtmlForWebview(this._view!.webview);\n      await this._refresh();\n      this._startPeriodicRefresh();\n\n      vscode.window.showInformationMessage('Todo board setup complete!');\n    } catch (error) {\n      console.error('Error saving wizard settings:', error);\n      this._view?.webview.postMessage({\n        type: 'error',\n        message: `Failed to save settings: ${error}`\n      });\n    }\n  }\n\n  private async _handleCancelWizard() {\n    // User wants to skip the wizard - just close or show the \"no file\" message\n    vscode.window.showInformationMessage(\n      'You can open a markdown file anytime using the command \"Todo Sidebar: Open Markdown File\"'\n    );\n  }\n\n  public dispose() {\n    this._stopPeriodicRefresh();\n    for (const disposable of this._disposables) {\n      disposable.dispose();\n    }\n  }\n}\n\nfunction getNonce() {\n  let text = '';\n  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  for (let i = 0; i < 32; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }\n  return text;\n}\n","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["context","console","log","kanbanProvider","KanbanViewProvider","subscriptions","push","vscode","window","registerWebviewViewProvider","viewType","openFileCommand","commands","registerCommand","async","fileUri","showOpenDialog","canSelectFiles","canSelectFolders","canSelectMany","filters","title","setActiveFile","showInformationMessage","fsPath","refreshCommand","refresh","dispose","content","lines","replace","split","board","description","columns","currentColumn","taskStack","foundFirstColumn","i","length","line","lineNumber","titleMatch","match","TITLE_REGEX","trim","descMatch","DESCRIPTION_REGEX","columnMatch","COLUMN_HEADER_REGEX","isDoneColumn","toLowerCase","includes","tasks","taskMatch","MD_TASK_REGEX","indent","checked","task","text","children","hasCheckbox","pop","unicodeTaskMatch","UNICODE_TASK_REGEX","checkChar","nestedQuoteMatch","NESTED_QUOTE_REGEX","childTask","bulletMatch","BULLET_REGEX","CHECKBOX_PREFIX_REGEX","module","exports","require","lineEnding","parseContentLines","lineIndex","currentLine","newLine","MD_CHECKBOX_UNCHECKED_REGEX","UNICODE_CHECKBOX_UNCHECKED_REGEX","MD_CHECKBOX_CHECKED_REGEX","UNICODE_CHECKBOX_CHECKED_REGEX","join","taskLine","targetSectionTitle","position","afterLine","taskLines","taskIndent","INDENT_REGEX","currentIndent","deindentedLines","map","startsWith","repeat","slice","newLines","targetInsertIndex","adjustedAfterLine","undefined","j","sectionMatch","SECTION_HEADER_REGEX","sectionTitle","insertAfterHeader","afterIndex","afterTaskIndent","insertAfter","endOfSection","result","cleaned","lastWasEmpty","resultLine","isEmpty","parentLine","taskIndex","parentIndex","descendantLine","ancestorLine","ancestorIndex","descendantIndex","ancestorIndent","isDescendantOf","taskContent","TASK_WITH_MD_CHECKBOX_REGEX","checkboxPart","taskText","parentContent","parentIndent","childIndent","originalTaskIndent","childMatch","newIndent","originalTaskBlockLength","adjustedParentIndex","insertIndex","adjustedParentContent","adjustedParentIndent","sectionIndex","splice","newText","mdMatch","TASK_TEXT_MD_CHECKBOX_REGEX","unicodeMatch","TASK_TEXT_UNICODE_CHECKBOX_REGEX","newTask","linesToRemove","getNonce","charAt","Math","floor","possible","random","_context","static","_view","_activeFileUri","_board","_disposables","_pendingEditLine","_historyStack","_historyIndex","_maxHistorySize","_isUndoRedo","_periodicRefreshTimer","_periodicRefreshInterval","constructor","resolveWebviewView","webviewView","_token","this","webview","options","enableScripts","localResourceRoots","extensionUri","onDidChangeVisibility","visible","_refresh","_startPeriodicRefresh","_stopPeriodicRefresh","onDidReceiveMessage","message","type","_handleToggle","targetColumn","_handleMove","targetSection","_handleOpenAtLine","postMessage","c","_handleMoveToParent","_handleAddTask","section","_handleEditTaskText","_handleAddSubtask","_handleUndo","_handleRedo","_handleDeleteTask","_handleHideSection","_handleSelectFile","_handleSaveWizard","filePath","onDoneAction","_handleCancelWizard","_setupFileWatchers","savedPath","workspace","getConfiguration","get","path","isAbsolute","workspaceFolder","workspaceFolders","Uri","joinPath","uri","file","e","error","setInterval","clearInterval","onDidChangeTextDocument","document","toString","watcher","createFileSystemWatcher","onDidChange","settingsWatcher","_reloadActiveFileFromConfig","onDidChangeConfiguration","affectsConfiguration","showWarningMessage","vscodeDir","settingsPath","fs","stat","createDirectory","existingText","fileExists","readFile","Buffer","from","savePath","relativePath","relative","escapedPath","JSON","stringify","activeFilePattern","onDoneActionPattern","hasActiveFile","test","hasOnDoneAction","insertMatch","insertPos","before","after","writeFile","showErrorMessage","_readActiveFile","_writeActiveFile","shift","previousContent","nextContent","html","_getHtmlForWebview","parseMarkdown","hiddenSections","filteredBoard","filter","col","_isColumnHidden","editLine","_getWelcomeHtmlForWebview","currentBoard","isTopLevel","_isTopLevelTaskInBoard","deleteTaskInContent","toggleTaskInContent","doneColumn","find","_findTaskColumnInBoard","moveTaskInContent","column","findInTasks","columnTitle","hiddenPatterns","lowerTitle","pattern","lowerPattern","RegExp","regexPattern","moveTaskToParent","openTextDocument","editor","showTextDocument","Position","selection","Selection","revealRange","Range","TextEditorRevealType","InCenter","addTaskToSection","editTaskTextInContent","addSubtaskToParent","escapedArray","settingPattern","nonce","htmlPath","extensionPath","readFileSync","cspSource","welcomePath","tipsPath","tipsContent","escapedAction","disposable","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"ignoreList":[],"sourceRoot":""}