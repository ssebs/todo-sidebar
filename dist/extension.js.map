{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://todo-sidebar-md/./src/extension.ts","webpack://todo-sidebar-md/./src/parser.ts","webpack://todo-sidebar-md/external commonjs \"vscode\"","webpack://todo-sidebar-md/./src/serializer.ts","webpack://todo-sidebar-md/external node-commonjs \"fs\"","webpack://todo-sidebar-md/./src/KanbanViewProvider.ts","webpack://todo-sidebar-md/external node-commonjs \"path\"","webpack://todo-sidebar-md/webpack/bootstrap","webpack://todo-sidebar-md/webpack/startup"],"sourcesContent":["import * as vscode from 'vscode';\nimport { KanbanViewProvider } from './KanbanViewProvider';\n\nlet kanbanProvider: KanbanViewProvider;\n\nexport function activate(context: vscode.ExtensionContext) {\n\tconsole.log('Todo Sidebar extension is now active!');\n\n\t// Create and register the webview provider\n\tkanbanProvider = new KanbanViewProvider(context);\n\tcontext.subscriptions.push(\n\t\tvscode.window.registerWebviewViewProvider(\n\t\t\tKanbanViewProvider.viewType,\n\t\t\tkanbanProvider\n\t\t)\n\t);\n\n\t// Register open file command\n\tconst openFileCommand = vscode.commands.registerCommand('todoSidebar.openFile', async () => {\n\t\tconst fileUri = await vscode.window.showOpenDialog({\n\t\t\tcanSelectFiles: true,\n\t\t\tcanSelectFolders: false,\n\t\t\tcanSelectMany: false,\n\t\t\tfilters: {\n\t\t\t\t'Markdown': ['md']\n\t\t\t},\n\t\t\ttitle: 'Select a Markdown file for the Todo Board'\n\t\t});\n\n\t\tif (fileUri && fileUri[0]) {\n\t\t\tawait kanbanProvider.setActiveFile(fileUri[0]);\n\t\t\tvscode.window.showInformationMessage(`Loaded: ${fileUri[0].fsPath}`);\n\t\t}\n\t});\n\n\t// Register refresh command\n\tconst refreshCommand = vscode.commands.registerCommand('todoSidebar.refresh', async () => {\n\t\tawait kanbanProvider.refresh();\n\t});\n\n\tcontext.subscriptions.push(openFileCommand, refreshCommand);\n}\n\nexport function deactivate() {\n\tif (kanbanProvider) {\n\t\tkanbanProvider.dispose();\n\t}\n}\n","export interface Task {\n  text: string;\n  checked: boolean;\n  line: number;\n  children: Task[];\n  hasCheckbox: boolean;\n}\n\nexport interface Column {\n  title: string;\n  line: number;\n  isDoneColumn: boolean;\n  tasks: Task[];\n}\n\nexport interface Board {\n  title: string;\n  description: string;\n  columns: Column[];\n}\n\n// Regex constants for parsing markdown patterns\nconst TITLE_REGEX = /^#\\s+([^#].*)$/;\nconst DESCRIPTION_REGEX = /^>\\s*(.*)$/;\nconst COLUMN_HEADER_REGEX = /^##\\s+(.+)$/;\nconst MD_TASK_REGEX = /^(\\s*)[-*]\\s+\\[([ xX])\\]\\s+(.+)$/;\nconst UNICODE_TASK_REGEX = /^(\\s*)[-*]\\s+([☐☑✓✗])\\s+(.+)$/;\nconst NESTED_QUOTE_REGEX = /^(\\s*)[-*]\\s+>\\s*(.+)$/;\nconst BULLET_REGEX = /^(\\s+)[-*]\\s+(.+)$/;\nconst CHECKBOX_PREFIX_REGEX = /^\\[[ xX]\\]|^[☐☑✓✗]/;\n\nexport function parseMarkdown(content: string): Board {\n  // Normalize line endings (handle Windows \\r\\n and Mac \\r)\n  const normalizedContent = content.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n  const lines = normalizedContent.split('\\n');\n  const board: Board = {\n    title: '',\n    description: '',\n    columns: []\n  };\n\n  let currentColumn: Column | null = null;\n  let taskStack: { task: Task; indent: number }[] = [];\n  let foundFirstColumn = false;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const lineNumber = i + 1; // 1-indexed for editor navigation\n\n    // Board title: # Title (only before first column)\n    if (!foundFirstColumn) {\n      const titleMatch = line.match(TITLE_REGEX);\n      if (titleMatch) {\n        board.title = titleMatch[1].trim();\n        continue;\n      }\n\n      // Description: > text (only before first column, not indented)\n      const descMatch = line.match(DESCRIPTION_REGEX);\n      if (descMatch) {\n        if (board.description) {\n          board.description += '\\n' + descMatch[1];\n        } else {\n          board.description = descMatch[1];\n        }\n        continue;\n      }\n    }\n\n    // Column header: ## Section\n    const columnMatch = line.match(COLUMN_HEADER_REGEX);\n    if (columnMatch) {\n      foundFirstColumn = true;\n      const title = columnMatch[1].trim();\n      currentColumn = {\n        title,\n        line: lineNumber,\n        isDoneColumn: title.toLowerCase().includes('done'),\n        tasks: []\n      };\n      board.columns.push(currentColumn);\n      taskStack = [];\n      continue;\n    }\n\n    // Task with markdown checkbox: - [ ] or - [x] or * [ ] or * [x]\n    const taskMatch = line.match(MD_TASK_REGEX);\n    if (taskMatch && currentColumn) {\n      const indent = taskMatch[1].length;\n      const checked = taskMatch[2].toLowerCase() === 'x';\n      const text = taskMatch[3].trim();\n\n      const task: Task = {\n        text,\n        checked,\n        line: lineNumber,\n        children: [],\n        hasCheckbox: true\n      };\n\n      // Find parent based on indentation\n      while (taskStack.length > 0 && taskStack[taskStack.length - 1].indent >= indent) {\n        taskStack.pop();\n      }\n\n      if (taskStack.length > 0) {\n        // Add as child to parent\n        taskStack[taskStack.length - 1].task.children.push(task);\n      } else {\n        // Add as top-level task\n        currentColumn.tasks.push(task);\n      }\n\n      taskStack.push({ task, indent });\n      continue;\n    }\n\n    // Task with unicode checkbox: * ☐ or * ☑ or - ☐ or - ☑\n    const unicodeTaskMatch = line.match(UNICODE_TASK_REGEX);\n    if (unicodeTaskMatch && currentColumn) {\n      const indent = unicodeTaskMatch[1].length;\n      const checkChar = unicodeTaskMatch[2];\n      const checked = checkChar === '☑' || checkChar === '✓';\n      const text = unicodeTaskMatch[3].trim();\n\n      const task: Task = {\n        text,\n        checked,\n        line: lineNumber,\n        children: [],\n        hasCheckbox: true\n      };\n\n      while (taskStack.length > 0 && taskStack[taskStack.length - 1].indent >= indent) {\n        taskStack.pop();\n      }\n\n      if (taskStack.length > 0) {\n        taskStack[taskStack.length - 1].task.children.push(task);\n      } else {\n        currentColumn.tasks.push(task);\n      }\n\n      taskStack.push({ task, indent });\n      continue;\n    }\n\n    // Nested item with > prefix (like \"  * > really good\")\n    const nestedQuoteMatch = line.match(NESTED_QUOTE_REGEX);\n    if (nestedQuoteMatch && taskStack.length > 0) {\n      const text = nestedQuoteMatch[2].trim();\n\n      const childTask: Task = {\n        text,\n        checked: false,\n        line: lineNumber,\n        children: [],\n        hasCheckbox: false\n      };\n\n      // Add to most recent task\n      taskStack[taskStack.length - 1].task.children.push(childTask);\n      continue;\n    }\n\n    // Nested bullet point: - item or * item (without checkbox, indented)\n    const bulletMatch = line.match(BULLET_REGEX);\n    if (bulletMatch && taskStack.length > 0) {\n      const indent = bulletMatch[1].length;\n      const text = bulletMatch[2].trim();\n\n      // Skip if it looks like a checkbox we didn't match\n      if (text.match(CHECKBOX_PREFIX_REGEX)) {\n        continue;\n      }\n\n      const childTask: Task = {\n        text,\n        checked: false,\n        line: lineNumber,\n        children: [],\n        hasCheckbox: false\n      };\n\n      // Find appropriate parent based on indentation\n      while (taskStack.length > 1 && taskStack[taskStack.length - 1].indent >= indent) {\n        taskStack.pop();\n      }\n\n      if (taskStack.length > 0) {\n        taskStack[taskStack.length - 1].task.children.push(childTask);\n      }\n    }\n  }\n\n  return board;\n}\n","module.exports = require(\"vscode\");","// Regex constants for checkbox and indentation patterns\nconst INDENT_REGEX = /^(\\s*)/;\nconst MD_CHECKBOX_UNCHECKED_REGEX = /([-*]\\s+)\\[ \\]/;\nconst MD_CHECKBOX_CHECKED_REGEX = /([-*]\\s+)\\[[xX]\\]/;\nconst UNICODE_CHECKBOX_UNCHECKED_REGEX = /([-*]\\s+)☐/;\nconst UNICODE_CHECKBOX_CHECKED_REGEX = /([-*]\\s+)[☑✓]/;\nconst TASK_WITH_MD_CHECKBOX_REGEX = /^\\s*[-*]\\s+(\\[[ xX]\\]|[☐☑✓✗])?\\s*(.+)$/;\nconst TASK_TEXT_MD_CHECKBOX_REGEX = /^(\\s*[-*]\\s+\\[[ xX]\\]\\s+)(.+)$/;\nconst TASK_TEXT_UNICODE_CHECKBOX_REGEX = /^(\\s*[-*]\\s+[☐☑✓✗]\\s+)(.+)$/;\nconst SECTION_HEADER_REGEX = /^##\\s+(.+)$/;\n\n/**\n * Helper function to parse content into lines while preserving line ending style\n */\nfunction parseContentLines(content: string): { lines: string[]; lineEnding: string } {\n  const lineEnding = content.includes('\\r\\n') ? '\\r\\n' : '\\n';\n  const lines = content.split(/\\r?\\n/);\n  return { lines, lineEnding };\n}\n\nexport function toggleTaskInContent(content: string, line: number, checked: boolean): string {\n  const { lines, lineEnding } = parseContentLines(content);\n  const lineIndex = line - 1; // Convert to 0-indexed\n\n  if (lineIndex >= 0 && lineIndex < lines.length) {\n    const currentLine = lines[lineIndex];\n    if (checked) {\n      // Handle markdown checkboxes: - [ ] or * [ ]\n      let newLine = currentLine.replace(MD_CHECKBOX_UNCHECKED_REGEX, '$1[x]');\n      // Handle unicode checkboxes: ☐ -> ☑\n      newLine = newLine.replace(UNICODE_CHECKBOX_UNCHECKED_REGEX, '$1☑');\n      lines[lineIndex] = newLine;\n    } else {\n      // Handle markdown checkboxes: - [x] or * [x]\n      let newLine = currentLine.replace(MD_CHECKBOX_CHECKED_REGEX, '$1[ ]');\n      // Handle unicode checkboxes: ☑ or ✓ -> ☐\n      newLine = newLine.replace(UNICODE_CHECKBOX_CHECKED_REGEX, '$1☐');\n      lines[lineIndex] = newLine;\n    }\n  }\n\n  return lines.join(lineEnding);\n}\n\nexport function moveTaskInContent(\n  content: string,\n  taskLine: number,\n  targetSectionTitle: string,\n  position: 'top' | 'bottom' | 'after' = 'bottom',\n  afterLine?: number\n): string {\n  const { lines, lineEnding } = parseContentLines(content);\n  const lineIndex = taskLine - 1;\n\n  // Find the task and all its children (indented lines below it)\n  const taskLines: string[] = [];\n  const taskIndent = lines[lineIndex]?.match(INDENT_REGEX)?.[1].length ?? 0;\n\n  // Add the task line\n  taskLines.push(lines[lineIndex]);\n\n  // Add all children (lines with greater indentation following the task)\n  let i = lineIndex + 1;\n  while (i < lines.length) {\n    const currentLine = lines[i];\n    const currentIndent = currentLine.match(INDENT_REGEX)?.[1].length ?? 0;\n\n    // Empty line or line with content at same/less indentation ends the block\n    if (currentLine.trim() === '') {\n      break;\n    }\n    if (currentIndent <= taskIndent && currentLine.trim() !== '') {\n      break;\n    }\n\n    taskLines.push(currentLine);\n    i++;\n  }\n\n  // De-indent the task block to become top-level\n  const deindentedLines = taskLines.map(line => {\n    if (line.startsWith(' '.repeat(taskIndent))) {\n      return line.slice(taskIndent);\n    }\n    return line;\n  });\n\n  // Remove the task block from original position\n  const beforeTask = lines.slice(0, lineIndex);\n  const afterTask = lines.slice(lineIndex + taskLines.length);\n  const newLines = [...beforeTask, ...afterTask];\n\n  // Find the target section and insert position\n  let targetInsertIndex = -1;\n\n  // If position is 'after', we need to find the line to insert after\n  // The afterLine was given in original line numbers, but we need to adjust for removed lines\n  let adjustedAfterLine = afterLine;\n  if (afterLine !== undefined && taskLine < afterLine) {\n    // Task was removed from before afterLine, so adjust\n    adjustedAfterLine = afterLine - taskLines.length;\n  }\n\n  for (let j = 0; j < newLines.length; j++) {\n    const sectionMatch = newLines[j].match(SECTION_HEADER_REGEX);\n    if (sectionMatch) {\n      const sectionTitle = sectionMatch[1].trim();\n      if (sectionTitle === targetSectionTitle || sectionTitle.startsWith(targetSectionTitle)) {\n        if (position === 'top') {\n          // Insert right after the section header (skip empty lines)\n          let insertAfterHeader = j + 1;\n          while (insertAfterHeader < newLines.length && newLines[insertAfterHeader].trim() === '') {\n            insertAfterHeader++;\n          }\n          targetInsertIndex = insertAfterHeader;\n        } else if (position === 'after' && adjustedAfterLine !== undefined) {\n          // Find the task at adjustedAfterLine and insert after it and its children\n          const afterIndex = adjustedAfterLine - 1; // Convert to 0-indexed\n          if (afterIndex >= 0 && afterIndex < newLines.length) {\n            const afterTaskIndent = newLines[afterIndex]?.match(INDENT_REGEX)?.[1].length ?? 0;\n            let insertAfter = afterIndex + 1;\n            // Skip over children of the after task\n            while (insertAfter < newLines.length) {\n              const currentLine = newLines[insertAfter];\n              const currentIndent = currentLine.match(INDENT_REGEX)?.[1].length ?? 0;\n              if (currentLine.trim() === '' || currentIndent <= afterTaskIndent) {\n                break;\n              }\n              insertAfter++;\n            }\n            targetInsertIndex = insertAfter;\n          }\n        } else {\n          // 'bottom' - Find the end of this section\n          let endOfSection = j + 1;\n          while (endOfSection < newLines.length) {\n            if (newLines[endOfSection].match(SECTION_HEADER_REGEX)) {\n              break;\n            }\n            endOfSection++;\n          }\n          targetInsertIndex = endOfSection;\n        }\n        break;\n      }\n    }\n  }\n\n  if (targetInsertIndex === -1) {\n    // Target section not found, return unchanged\n    return content;\n  }\n\n  // Insert task lines at the target position\n  const result = [\n    ...newLines.slice(0, targetInsertIndex),\n    ...deindentedLines,\n    '',\n    ...newLines.slice(targetInsertIndex)\n  ];\n\n  // Clean up multiple consecutive empty lines\n  const cleaned: string[] = [];\n  let lastWasEmpty = false;\n  for (const resultLine of result) {\n    const isEmpty = resultLine.trim() === '';\n    if (isEmpty && lastWasEmpty) {\n      continue;\n    }\n    cleaned.push(resultLine);\n    lastWasEmpty = isEmpty;\n  }\n\n  return cleaned.join(lineEnding);\n}\n\nexport function moveTaskToParent(\n  content: string,\n  taskLine: number,\n  parentLine: number,\n  position: 'top' | 'bottom' | 'after' = 'bottom',\n  afterLine?: number\n): string {\n  const { lines, lineEnding } = parseContentLines(content);\n  const taskIndex = taskLine - 1;\n  const parentIndex = parentLine - 1;\n\n  // Get the task line content\n  const taskContent = lines[taskIndex];\n  if (!taskContent) {\n    return content;\n  }\n\n  // Extract task text (remove leading whitespace, bullet, and checkbox)\n  const taskMatch = taskContent.match(TASK_WITH_MD_CHECKBOX_REGEX);\n  if (!taskMatch) {\n    return content;\n  }\n  const checkboxPart = taskMatch[1] || '[ ]';\n  const taskText = taskMatch[2];\n\n  // Get the parent's indentation level\n  const parentContent = lines[parentIndex];\n  if (!parentContent) {\n    return content;\n  }\n  const parentIndent = parentContent.match(INDENT_REGEX)?.[1].length ?? 0;\n  const childIndent = ' '.repeat(parentIndent + 2);\n\n  // Find all children of the task being moved (to move them too)\n  const taskLines: string[] = [];\n  const originalTaskIndent = taskContent.match(INDENT_REGEX)?.[1].length ?? 0;\n\n  // The task itself, re-indented as a child\n  taskLines.push(`${childIndent}- ${checkboxPart} ${taskText}`);\n\n  // Find and re-indent any children of the moved task\n  let i = taskIndex + 1;\n  while (i < lines.length) {\n    const currentLine = lines[i];\n    const currentIndent = currentLine.match(INDENT_REGEX)?.[1].length ?? 0;\n\n    if (currentLine.trim() === '') {\n      break;\n    }\n    if (currentIndent <= originalTaskIndent && currentLine.trim() !== '') {\n      break;\n    }\n\n    // Re-indent the child line\n    const childMatch = currentLine.match(/^(\\s*)(.+)$/);\n    if (childMatch) {\n      const relativeIndent = currentIndent - originalTaskIndent;\n      const newIndent = ' '.repeat(parentIndent + 2 + relativeIndent);\n      taskLines.push(`${newIndent}${childMatch[2]}`);\n    }\n    i++;\n  }\n\n  // Remove the task (and its children) from original position\n  const originalTaskBlockLength = i - taskIndex;\n\n  // Calculate adjusted parent index after removal\n  let adjustedParentIndex = parentIndex;\n  if (taskIndex < parentIndex) {\n    adjustedParentIndex = parentIndex - originalTaskBlockLength;\n  }\n\n  // Remove task block\n  const beforeTask = lines.slice(0, taskIndex);\n  const afterTask = lines.slice(taskIndex + originalTaskBlockLength);\n  const newLines = [...beforeTask, ...afterTask];\n\n  // Find insertion point - right after the parent or at end of parent's children\n  let insertIndex: number;\n  const adjustedParentContent = newLines[adjustedParentIndex];\n  const adjustedParentIndent = adjustedParentContent?.match(INDENT_REGEX)?.[1].length ?? 0;\n\n  if (position === 'top') {\n    // Insert right after parent line\n    insertIndex = adjustedParentIndex + 1;\n  } else if (position === 'after' && afterLine !== undefined) {\n    // Calculate adjusted afterLine\n    let adjustedAfterLine = afterLine;\n    if (taskIndex < afterLine) {\n      adjustedAfterLine = afterLine - originalTaskBlockLength;\n    }\n    const afterIndex = adjustedAfterLine - 1; // Convert to 0-indexed\n    if (afterIndex >= 0 && afterIndex < newLines.length) {\n      // Find end of the \"after\" task's children\n      const afterTaskIndent = newLines[afterIndex]?.match(INDENT_REGEX)?.[1].length ?? 0;\n      insertIndex = afterIndex + 1;\n      while (insertIndex < newLines.length) {\n        const currentLine = newLines[insertIndex];\n        const currentIndent = currentLine.match(INDENT_REGEX)?.[1].length ?? 0;\n        if (currentLine.trim() === '' || currentIndent <= afterTaskIndent) {\n          break;\n        }\n        insertIndex++;\n      }\n    } else {\n      // Fallback to end of parent's children\n      insertIndex = adjustedParentIndex + 1;\n    }\n  } else {\n    // 'bottom' - Find end of parent's children\n    insertIndex = adjustedParentIndex + 1;\n    while (insertIndex < newLines.length) {\n      const currentLine = newLines[insertIndex];\n      const currentIndent = currentLine.match(INDENT_REGEX)?.[1].length ?? 0;\n\n      if (currentLine.trim() === '') {\n        break;\n      }\n      if (currentIndent <= adjustedParentIndent) {\n        break;\n      }\n      insertIndex++;\n    }\n  }\n\n  // Insert the task lines\n  const result = [\n    ...newLines.slice(0, insertIndex),\n    ...taskLines,\n    ...newLines.slice(insertIndex)\n  ];\n\n  // Clean up multiple consecutive empty lines\n  const cleaned: string[] = [];\n  let lastWasEmpty = false;\n  for (const resultLine of result) {\n    const isEmpty = resultLine.trim() === '';\n    if (isEmpty && lastWasEmpty) {\n      continue;\n    }\n    cleaned.push(resultLine);\n    lastWasEmpty = isEmpty;\n  }\n\n  return cleaned.join(lineEnding);\n}\n\nexport function addTaskToSection(\n  content: string,\n  sectionTitle: string\n): { content: string; line: number } {\n  const { lines, lineEnding } = parseContentLines(content);\n\n  // Find the section header\n  let sectionIndex = -1;\n  for (let i = 0; i < lines.length; i++) {\n    const match = lines[i].match(SECTION_HEADER_REGEX);\n    if (match && match[1].trim() === sectionTitle) {\n      sectionIndex = i;\n      break;\n    }\n  }\n\n  if (sectionIndex === -1) {\n    return { content, line: -1 };\n  }\n\n  // Find insertion point (skip blank lines after header)\n  let insertIndex = sectionIndex + 1;\n  while (insertIndex < lines.length && lines[insertIndex].trim() === '') {\n    insertIndex++;\n  }\n\n  // Insert new task\n  const newTask = '- [ ] New task';\n  lines.splice(insertIndex, 0, newTask);\n\n  return {\n    content: lines.join(lineEnding),\n    line: insertIndex + 1 // 1-indexed\n  };\n}\n\nexport function editTaskTextInContent(\n  content: string,\n  line: number,\n  newText: string\n): string {\n  const { lines, lineEnding } = parseContentLines(content);\n  const lineIndex = line - 1;\n\n  if (lineIndex < 0 || lineIndex >= lines.length) {\n    return content;\n  }\n\n  const currentLine = lines[lineIndex];\n\n  // Match markdown checkbox: - [ ] text or - [x] text\n  const mdMatch = currentLine.match(TASK_TEXT_MD_CHECKBOX_REGEX);\n  if (mdMatch) {\n    lines[lineIndex] = mdMatch[1] + newText;\n    return lines.join(lineEnding);\n  }\n\n  // Match unicode checkbox: - ☐ text or - ☑ text\n  const unicodeMatch = currentLine.match(TASK_TEXT_UNICODE_CHECKBOX_REGEX);\n  if (unicodeMatch) {\n    lines[lineIndex] = unicodeMatch[1] + newText;\n    return lines.join(lineEnding);\n  }\n\n  return content;\n}\n\nexport function addSubtaskToParent(\n  content: string,\n  parentLine: number\n): { content: string; line: number } {\n  const { lines, lineEnding } = parseContentLines(content);\n  const parentIndex = parentLine - 1;\n\n  if (parentIndex < 0 || parentIndex >= lines.length) {\n    return { content, line: -1 };\n  }\n\n  const parentContent = lines[parentIndex];\n  const parentIndent = parentContent.match(INDENT_REGEX)?.[1].length ?? 0;\n  const childIndent = ' '.repeat(parentIndent + 2);\n\n  // Find insertion point: after parent and all its existing children\n  let insertIndex = parentIndex + 1;\n  while (insertIndex < lines.length) {\n    const currentLine = lines[insertIndex];\n    const currentIndent = currentLine.match(INDENT_REGEX)?.[1].length ?? 0;\n\n    if (currentLine.trim() === '') {\n      break;\n    }\n    if (currentIndent <= parentIndent) {\n      break;\n    }\n    insertIndex++;\n  }\n\n  // Insert new subtask\n  const newTask = `${childIndent}- [ ] New task`;\n  lines.splice(insertIndex, 0, newTask);\n\n  return {\n    content: lines.join(lineEnding),\n    line: insertIndex + 1 // 1-indexed\n  };\n}\n\nexport function removeCheckboxFromTask(\n  content: string,\n  line: number\n): string {\n  const { lines, lineEnding } = parseContentLines(content);\n  const lineIndex = line - 1;\n\n  if (lineIndex < 0 || lineIndex >= lines.length) {\n    return content;\n  }\n\n  const currentLine = lines[lineIndex];\n\n  // Match markdown checkbox: - [ ] text or - [x] text and convert to - text\n  const mdMatch = currentLine.match(/^(\\s*[-*]\\s+)\\[[ xX]\\]\\s+(.+)$/);\n  if (mdMatch) {\n    lines[lineIndex] = mdMatch[1] + mdMatch[2];\n    return lines.join(lineEnding);\n  }\n\n  // Match unicode checkbox: - ☐ text or - ☑ text and convert to - text\n  const unicodeMatch = currentLine.match(/^(\\s*[-*]\\s+)[☐☑✓✗]\\s+(.+)$/);\n  if (unicodeMatch) {\n    lines[lineIndex] = unicodeMatch[1] + unicodeMatch[2];\n    return lines.join(lineEnding);\n  }\n\n  return content;\n}\n","module.exports = require(\"fs\");","import * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { parseMarkdown, Board, Task, Column } from './parser';\nimport { toggleTaskInContent, moveTaskInContent, moveTaskToParent, addTaskToSection, editTaskTextInContent, addSubtaskToParent } from './serializer';\n\nexport class KanbanViewProvider implements vscode.WebviewViewProvider {\n  public static readonly viewType = 'todoSidebar.kanbanView';\n\n  private _view?: vscode.WebviewView;\n  private _activeFileUri?: vscode.Uri;\n  private _board?: Board;\n  private _disposables: vscode.Disposable[] = [];\n  private _pendingEditLine?: number;\n\n  constructor(private readonly _context: vscode.ExtensionContext) {}\n\n  public resolveWebviewView(\n    webviewView: vscode.WebviewView,\n    _context: vscode.WebviewViewResolveContext,\n    _token: vscode.CancellationToken\n  ) {\n    this._view = webviewView;\n\n    webviewView.webview.options = {\n      enableScripts: true,\n      localResourceRoots: [this._context.extensionUri]\n    };\n\n    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);\n\n    // Handle visibility changes - refresh when panel becomes visible\n    webviewView.onDidChangeVisibility(() => {\n      if (webviewView.visible && this._activeFileUri) {\n        this._refresh();\n      }\n    });\n\n    // Handle messages from webview\n    webviewView.webview.onDidReceiveMessage(async (message) => {\n      switch (message.type) {\n        case 'toggle':\n          await this._handleToggle(message.line, message.checked, message.targetColumn);\n          break;\n        case 'move':\n          await this._handleMove(message.taskLine, message.targetSection, message.position, message.afterLine);\n          break;\n        case 'openAtLine':\n          await this._handleOpenAtLine(message.line);\n          break;\n        case 'getColumns':\n          // Send column list back to webview for the picker\n          if (this._board) {\n            this._view?.webview.postMessage({\n              type: 'columnsForPicker',\n              columns: this._board.columns.map(c => ({ title: c.title, isDoneColumn: c.isDoneColumn })),\n              taskLine: message.line\n            });\n          }\n          break;\n        case 'moveToParent':\n          await this._handleMoveToParent(message.taskLine, message.parentLine, message.position, message.afterLine);\n          break;\n        case 'addTask':\n          await this._handleAddTask(message.section);\n          break;\n        case 'editTaskText':\n          await this._handleEditTaskText(message.line, message.newText);\n          break;\n        case 'addSubtask':\n          await this._handleAddSubtask(message.parentLine);\n          break;\n      }\n    });\n\n    // Set up file watchers only once\n    if (this._disposables.length === 0) {\n      this._setupFileWatchers();\n    }\n\n    // Restore file from workspace settings\n    const config = vscode.workspace.getConfiguration('todoSidebar');\n    const savedPath = config.get<string>('activeFile');\n    console.log('Attempting to restore activeFile from settings:', savedPath);\n    if (savedPath) {\n      try {\n        this._activeFileUri = vscode.Uri.file(savedPath);\n        console.log('Restored activeFile:', this._activeFileUri.fsPath);\n      } catch (e) {\n        console.error('Failed to restore saved file:', e);\n      }\n    }\n\n    // Always refresh when view becomes visible\n    if (this._activeFileUri) {\n      this._refresh();\n    }\n  }\n\n  private _setupFileWatchers() {\n    // Watch for text document changes\n    this._disposables.push(\n      vscode.workspace.onDidChangeTextDocument((e) => {\n        if (this._activeFileUri && e.document.uri.toString() === this._activeFileUri.toString()) {\n          this._refresh();\n        }\n      })\n    );\n\n    // Watch for file system changes\n    const watcher = vscode.workspace.createFileSystemWatcher('**/*.md');\n    this._disposables.push(\n      watcher.onDidChange((uri) => {\n        if (this._activeFileUri && uri.toString() === this._activeFileUri.toString()) {\n          this._refresh();\n        }\n      })\n    );\n    this._disposables.push(watcher);\n  }\n\n  public async setActiveFile(uri: vscode.Uri) {\n    this._activeFileUri = uri;\n\n    // Store in workspace settings by directly writing to .vscode/settings.json\n    try {\n      const hasWorkspaceFolder = vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0;\n\n      if (!hasWorkspaceFolder) {\n        console.error('No workspace folder open - cannot save to workspace settings');\n        vscode.window.showWarningMessage('Please open a folder/workspace to persist the todo file selection');\n        await this._refresh();\n        return;\n      }\n\n      const workspaceFolder = vscode.workspace.workspaceFolders![0];\n      const vscodeDir = vscode.Uri.joinPath(workspaceFolder.uri, '.vscode');\n      const settingsPath = vscode.Uri.joinPath(vscodeDir, 'settings.json');\n\n      // Ensure .vscode directory exists\n      try {\n        await vscode.workspace.fs.stat(vscodeDir);\n      } catch {\n        await vscode.workspace.fs.createDirectory(vscodeDir);\n        console.log('Created .vscode directory');\n      }\n\n      // Read existing settings or create new object\n      let settings: any = {};\n      let existingText = '';\n      try {\n        const content = await vscode.workspace.fs.readFile(settingsPath);\n        existingText = Buffer.from(content).toString('utf-8');\n        // Try to parse, stripping comments if needed\n        const stripped = existingText.replace(/\\/\\/.*$/gm, '').replace(/\\/\\*[\\s\\S]*?\\*\\//g, '');\n        settings = JSON.parse(stripped);\n      } catch (e) {\n        console.log('Creating new settings.json file (or couldn\\'t parse existing)');\n      }\n\n      // Update the todoSidebar.activeFile setting\n      settings['todoSidebar.activeFile'] = uri.fsPath;\n\n      // Write back to settings.json with proper formatting\n      const settingsText = JSON.stringify(settings, null, 4);\n      await vscode.workspace.fs.writeFile(settingsPath, Buffer.from(settingsText, 'utf-8'));\n      console.log('Saved activeFile to .vscode/settings.json:', uri.fsPath);\n\n    } catch (e) {\n      console.error('Failed to save activeFile to settings:', e);\n      vscode.window.showErrorMessage(`Failed to save todo file selection: ${e}`);\n    }\n    await this._refresh();\n  }\n\n  public async refresh() {\n    await this._refresh();\n  }\n\n  private async _readActiveFile(): Promise<string> {\n    if (!this._activeFileUri) {\n      return '';\n    }\n    const content = await vscode.workspace.fs.readFile(this._activeFileUri);\n    return Buffer.from(content).toString('utf-8');\n  }\n\n  private async _writeActiveFile(text: string): Promise<void> {\n    if (!this._activeFileUri) {\n      return;\n    }\n    await vscode.workspace.fs.writeFile(this._activeFileUri, Buffer.from(text, 'utf-8'));\n  }\n\n  private async _refresh() {\n    if (!this._activeFileUri || !this._view) {\n      return;\n    }\n\n    try {\n      const text = await this._readActiveFile();\n      this._board = parseMarkdown(text);\n      const editLine = this._pendingEditLine;\n      this._pendingEditLine = undefined;\n      this._view.webview.postMessage({ type: 'update', board: this._board, editLine });\n    } catch (error) {\n      console.error('Error refreshing kanban board:', error);\n    }\n  }\n\n  private async _handleToggle(line: number, checked: boolean, targetColumn?: string) {\n    if (!this._activeFileUri || !this._board) {\n      return;\n    }\n\n    try {\n      let text = await this._readActiveFile();\n\n      // Toggle the checkbox\n      text = toggleTaskInContent(text, line, checked);\n\n      // Only move top-level tasks to Done column (not subtasks)\n      const isTopLevel = this._isTopLevelTask(line);\n\n      if (checked && isTopLevel) {\n        // If checked and top-level, move to Done column at TOP\n        const doneColumn = this._board.columns.find((c) => c.isDoneColumn);\n        if (doneColumn) {\n          const currentColumn = this._findTaskColumn(line);\n          if (currentColumn && !currentColumn.isDoneColumn) {\n            text = moveTaskInContent(text, line, doneColumn.title, 'top');\n          }\n        }\n      } else if (targetColumn && isTopLevel) {\n        // If unchecked and a target column is specified, move there at TOP\n        text = moveTaskInContent(text, line, targetColumn, 'top');\n      }\n\n      await this._writeActiveFile(text);\n    } catch (error) {\n      console.error('Error toggling task:', error);\n    }\n  }\n\n  private _isTopLevelTask(line: number): boolean {\n    if (!this._board) {\n      return false;\n    }\n\n    for (const column of this._board.columns) {\n      for (const task of column.tasks) {\n        if (task.line === line) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  private _findTaskColumn(line: number): Column | undefined {\n    if (!this._board) {\n      return undefined;\n    }\n\n    const findInTasks = (tasks: Task[]): boolean => {\n      for (const task of tasks) {\n        if (task.line === line) {\n          return true;\n        }\n        if (findInTasks(task.children)) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    for (const column of this._board.columns) {\n      if (findInTasks(column.tasks)) {\n        return column;\n      }\n    }\n\n    return undefined;\n  }\n\n  private async _handleMove(taskLine: number, targetSection: string, position: 'top' | 'bottom' | 'after' = 'bottom', afterLine?: number) {\n    if (!this._activeFileUri) {\n      return;\n    }\n\n    try {\n      let text = await this._readActiveFile();\n      text = moveTaskInContent(text, taskLine, targetSection, position, afterLine);\n      await this._writeActiveFile(text);\n    } catch (error) {\n      console.error('Error moving task:', error);\n    }\n  }\n\n  private async _handleMoveToParent(taskLine: number, parentLine: number, position: 'top' | 'bottom' | 'after' = 'bottom', afterLine?: number) {\n    if (!this._activeFileUri) {\n      return;\n    }\n\n    try {\n      let text = await this._readActiveFile();\n      text = moveTaskToParent(text, taskLine, parentLine, position, afterLine);\n      await this._writeActiveFile(text);\n    } catch (error) {\n      console.error('Error moving task to parent:', error);\n    }\n  }\n\n  private async _handleOpenAtLine(line: number) {\n    if (!this._activeFileUri) {\n      return;\n    }\n\n    try {\n      const document = await vscode.workspace.openTextDocument(this._activeFileUri);\n      const editor = await vscode.window.showTextDocument(document);\n      const position = new vscode.Position(line - 1, 0);\n      editor.selection = new vscode.Selection(position, position);\n      editor.revealRange(new vscode.Range(position, position), vscode.TextEditorRevealType.InCenter);\n    } catch (error) {\n      console.error('Error opening file at line:', error);\n    }\n  }\n\n  private async _handleAddTask(section: string) {\n    if (!this._activeFileUri) {\n      return;\n    }\n\n    try {\n      const text = await this._readActiveFile();\n      const result = addTaskToSection(text, section);\n\n      if (result.line > 0) {\n        this._pendingEditLine = result.line;\n        await this._writeActiveFile(result.content);\n      }\n    } catch (error) {\n      console.error('Error adding task:', error);\n    }\n  }\n\n  private async _handleEditTaskText(line: number, newText: string) {\n    if (!this._activeFileUri) {\n      return;\n    }\n\n    try {\n      let text = await this._readActiveFile();\n      text = editTaskTextInContent(text, line, newText);\n      await this._writeActiveFile(text);\n    } catch (error) {\n      console.error('Error editing task text:', error);\n    }\n  }\n\n  private async _handleAddSubtask(parentLine: number) {\n    if (!this._activeFileUri) {\n      return;\n    }\n\n    try {\n      const text = await this._readActiveFile();\n      const result = addSubtaskToParent(text, parentLine);\n\n      if (result.line > 0) {\n        this._pendingEditLine = result.line;\n        await this._writeActiveFile(result.content);\n      }\n    } catch (error) {\n      console.error('Error adding subtask:', error);\n    }\n  }\n\n  private _getHtmlForWebview(webview: vscode.Webview): string {\n    const nonce = getNonce();\n\n    // Read the HTML template file\n    const htmlPath = path.join(this._context.extensionPath, 'src', 'webview.html');\n    let html = fs.readFileSync(htmlPath, 'utf-8');\n\n    // Replace placeholders with actual values\n    html = html.replace(/\\{\\{cspSource\\}\\}/g, webview.cspSource);\n    html = html.replace(/\\{\\{nonce\\}\\}/g, nonce);\n\n    return html;\n  }\n\n  public dispose() {\n    for (const disposable of this._disposables) {\n      disposable.dispose();\n    }\n  }\n}\n\nfunction getNonce() {\n  let text = '';\n  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  for (let i = 0; i < 32; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }\n  return text;\n}\n","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["context","console","log","kanbanProvider","KanbanViewProvider","subscriptions","push","vscode","window","registerWebviewViewProvider","viewType","openFileCommand","commands","registerCommand","async","fileUri","showOpenDialog","canSelectFiles","canSelectFolders","canSelectMany","filters","title","setActiveFile","showInformationMessage","fsPath","refreshCommand","refresh","dispose","content","lines","replace","split","board","description","columns","currentColumn","taskStack","foundFirstColumn","i","length","line","lineNumber","titleMatch","match","TITLE_REGEX","trim","descMatch","DESCRIPTION_REGEX","columnMatch","COLUMN_HEADER_REGEX","isDoneColumn","toLowerCase","includes","tasks","taskMatch","MD_TASK_REGEX","indent","checked","task","text","children","hasCheckbox","pop","unicodeTaskMatch","UNICODE_TASK_REGEX","checkChar","nestedQuoteMatch","NESTED_QUOTE_REGEX","childTask","bulletMatch","BULLET_REGEX","CHECKBOX_PREFIX_REGEX","module","exports","require","lineEnding","parseContentLines","lineIndex","currentLine","newLine","MD_CHECKBOX_UNCHECKED_REGEX","UNICODE_CHECKBOX_UNCHECKED_REGEX","MD_CHECKBOX_CHECKED_REGEX","UNICODE_CHECKBOX_CHECKED_REGEX","join","taskLine","targetSectionTitle","position","afterLine","taskLines","taskIndent","INDENT_REGEX","currentIndent","deindentedLines","map","startsWith","repeat","slice","newLines","targetInsertIndex","adjustedAfterLine","undefined","j","sectionMatch","SECTION_HEADER_REGEX","sectionTitle","insertAfterHeader","afterIndex","afterTaskIndent","insertAfter","endOfSection","result","cleaned","lastWasEmpty","resultLine","isEmpty","parentLine","taskIndex","parentIndex","taskContent","TASK_WITH_MD_CHECKBOX_REGEX","checkboxPart","taskText","parentContent","parentIndent","childIndent","originalTaskIndent","childMatch","newIndent","originalTaskBlockLength","adjustedParentIndex","insertIndex","adjustedParentContent","adjustedParentIndent","sectionIndex","splice","newText","mdMatch","TASK_TEXT_MD_CHECKBOX_REGEX","unicodeMatch","TASK_TEXT_UNICODE_CHECKBOX_REGEX","newTask","_context","static","_view","_activeFileUri","_board","_disposables","_pendingEditLine","constructor","resolveWebviewView","webviewView","_token","this","webview","options","enableScripts","localResourceRoots","extensionUri","html","_getHtmlForWebview","onDidChangeVisibility","visible","_refresh","onDidReceiveMessage","message","type","_handleToggle","targetColumn","_handleMove","targetSection","_handleOpenAtLine","postMessage","c","_handleMoveToParent","_handleAddTask","section","_handleEditTaskText","_handleAddSubtask","_setupFileWatchers","savedPath","workspace","getConfiguration","get","Uri","file","e","error","onDidChangeTextDocument","document","uri","toString","watcher","createFileSystemWatcher","onDidChange","workspaceFolders","showWarningMessage","workspaceFolder","vscodeDir","joinPath","settingsPath","fs","stat","createDirectory","settings","existingText","readFile","Buffer","from","stripped","JSON","parse","settingsText","stringify","writeFile","showErrorMessage","_readActiveFile","_writeActiveFile","parseMarkdown","editLine","toggleTaskInContent","isTopLevel","_isTopLevelTask","doneColumn","find","_findTaskColumn","moveTaskInContent","column","findInTasks","moveTaskToParent","openTextDocument","editor","showTextDocument","Position","selection","Selection","revealRange","Range","TextEditorRevealType","InCenter","addTaskToSection","editTaskTextInContent","addSubtaskToParent","nonce","possible","charAt","Math","floor","random","getNonce","htmlPath","path","extensionPath","readFileSync","cspSource","disposable","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"ignoreList":[],"sourceRoot":""}