{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://todo-sidebar/./src/extension.ts","webpack://todo-sidebar/./src/parser.ts","webpack://todo-sidebar/external commonjs \"vscode\"","webpack://todo-sidebar/./src/serializer.ts","webpack://todo-sidebar/./src/KanbanViewProvider.ts","webpack://todo-sidebar/webpack/bootstrap","webpack://todo-sidebar/webpack/startup"],"sourcesContent":["import * as vscode from 'vscode';\r\nimport { KanbanViewProvider } from './KanbanViewProvider';\r\n\r\nlet kanbanProvider: KanbanViewProvider;\r\n\r\nexport function activate(context: vscode.ExtensionContext) {\r\n\tconsole.log('Todo Sidebar extension is now active!');\r\n\r\n\t// Create and register the webview provider\r\n\tkanbanProvider = new KanbanViewProvider(context);\r\n\tcontext.subscriptions.push(\r\n\t\tvscode.window.registerWebviewViewProvider(\r\n\t\t\tKanbanViewProvider.viewType,\r\n\t\t\tkanbanProvider\r\n\t\t)\r\n\t);\r\n\r\n\t// Register open file command\r\n\tconst openFileCommand = vscode.commands.registerCommand('todoSidebar.openFile', async () => {\r\n\t\tconst fileUri = await vscode.window.showOpenDialog({\r\n\t\t\tcanSelectFiles: true,\r\n\t\t\tcanSelectFolders: false,\r\n\t\t\tcanSelectMany: false,\r\n\t\t\tfilters: {\r\n\t\t\t\t'Markdown': ['md']\r\n\t\t\t},\r\n\t\t\ttitle: 'Select a Markdown file for the Todo Board'\r\n\t\t});\r\n\r\n\t\tif (fileUri && fileUri[0]) {\r\n\t\t\tawait kanbanProvider.setActiveFile(fileUri[0]);\r\n\t\t\tvscode.window.showInformationMessage(`Loaded: ${fileUri[0].fsPath}`);\r\n\t\t}\r\n\t});\r\n\r\n\t// Register refresh command\r\n\tconst refreshCommand = vscode.commands.registerCommand('todoSidebar.refresh', async () => {\r\n\t\tawait kanbanProvider.refresh();\r\n\t});\r\n\r\n\tcontext.subscriptions.push(openFileCommand, refreshCommand);\r\n}\r\n\r\nexport function deactivate() {\r\n\tif (kanbanProvider) {\r\n\t\tkanbanProvider.dispose();\r\n\t}\r\n}\r\n","export interface Task {\r\n  text: string;\r\n  checked: boolean;\r\n  line: number;\r\n  children: Task[];\r\n  hasCheckbox: boolean;\r\n}\r\n\r\nexport interface Column {\r\n  title: string;\r\n  line: number;\r\n  isDoneColumn: boolean;\r\n  tasks: Task[];\r\n}\r\n\r\nexport interface Board {\r\n  title: string;\r\n  description: string;\r\n  columns: Column[];\r\n}\r\n\r\nexport function parseMarkdown(content: string): Board {\r\n  // Normalize line endings (handle Windows \\r\\n and Mac \\r)\r\n  const normalizedContent = content.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\r\n  const lines = normalizedContent.split('\\n');\r\n  const board: Board = {\r\n    title: '',\r\n    description: '',\r\n    columns: []\r\n  };\r\n\r\n  let currentColumn: Column | null = null;\r\n  let taskStack: { task: Task; indent: number }[] = [];\r\n  let foundFirstColumn = false;\r\n\r\n  for (let i = 0; i < lines.length; i++) {\r\n    const line = lines[i];\r\n    const lineNumber = i + 1; // 1-indexed for editor navigation\r\n\r\n    // Board title: # Title (only before first column)\r\n    if (!foundFirstColumn) {\r\n      const titleMatch = line.match(/^#\\s+([^#].*)$/);\r\n      if (titleMatch) {\r\n        board.title = titleMatch[1].trim();\r\n        continue;\r\n      }\r\n\r\n      // Description: > text (only before first column, not indented)\r\n      const descMatch = line.match(/^>\\s*(.*)$/);\r\n      if (descMatch) {\r\n        if (board.description) {\r\n          board.description += '\\n' + descMatch[1];\r\n        } else {\r\n          board.description = descMatch[1];\r\n        }\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // Column header: ## Section\r\n    const columnMatch = line.match(/^##\\s+(.+)$/);\r\n    if (columnMatch) {\r\n      foundFirstColumn = true;\r\n      const title = columnMatch[1].trim();\r\n      currentColumn = {\r\n        title,\r\n        line: lineNumber,\r\n        isDoneColumn: title.toLowerCase().includes('done'),\r\n        tasks: []\r\n      };\r\n      board.columns.push(currentColumn);\r\n      taskStack = [];\r\n      continue;\r\n    }\r\n\r\n    // Task with markdown checkbox: - [ ] or - [x] or * [ ] or * [x]\r\n    const taskMatch = line.match(/^(\\s*)[-*]\\s+\\[([ xX])\\]\\s+(.+)$/);\r\n    if (taskMatch && currentColumn) {\r\n      const indent = taskMatch[1].length;\r\n      const checked = taskMatch[2].toLowerCase() === 'x';\r\n      const text = taskMatch[3].trim();\r\n\r\n      const task: Task = {\r\n        text,\r\n        checked,\r\n        line: lineNumber,\r\n        children: [],\r\n        hasCheckbox: true\r\n      };\r\n\r\n      // Find parent based on indentation\r\n      while (taskStack.length > 0 && taskStack[taskStack.length - 1].indent >= indent) {\r\n        taskStack.pop();\r\n      }\r\n\r\n      if (taskStack.length > 0) {\r\n        // Add as child to parent\r\n        taskStack[taskStack.length - 1].task.children.push(task);\r\n      } else {\r\n        // Add as top-level task\r\n        currentColumn.tasks.push(task);\r\n      }\r\n\r\n      taskStack.push({ task, indent });\r\n      continue;\r\n    }\r\n\r\n    // Task with unicode checkbox: * ☐ or * ☑ or - ☐ or - ☑\r\n    const unicodeTaskMatch = line.match(/^(\\s*)[-*]\\s+([☐☑✓✗])\\s+(.+)$/);\r\n    if (unicodeTaskMatch && currentColumn) {\r\n      const indent = unicodeTaskMatch[1].length;\r\n      const checkChar = unicodeTaskMatch[2];\r\n      const checked = checkChar === '☑' || checkChar === '✓';\r\n      const text = unicodeTaskMatch[3].trim();\r\n\r\n      const task: Task = {\r\n        text,\r\n        checked,\r\n        line: lineNumber,\r\n        children: [],\r\n        hasCheckbox: true\r\n      };\r\n\r\n      while (taskStack.length > 0 && taskStack[taskStack.length - 1].indent >= indent) {\r\n        taskStack.pop();\r\n      }\r\n\r\n      if (taskStack.length > 0) {\r\n        taskStack[taskStack.length - 1].task.children.push(task);\r\n      } else {\r\n        currentColumn.tasks.push(task);\r\n      }\r\n\r\n      taskStack.push({ task, indent });\r\n      continue;\r\n    }\r\n\r\n    // Nested item with > prefix (like \"  * > really good\")\r\n    const nestedQuoteMatch = line.match(/^(\\s*)[-*]\\s+>\\s*(.+)$/);\r\n    if (nestedQuoteMatch && taskStack.length > 0) {\r\n      const text = nestedQuoteMatch[2].trim();\r\n\r\n      const childTask: Task = {\r\n        text,\r\n        checked: false,\r\n        line: lineNumber,\r\n        children: [],\r\n        hasCheckbox: false\r\n      };\r\n\r\n      // Add to most recent task\r\n      taskStack[taskStack.length - 1].task.children.push(childTask);\r\n      continue;\r\n    }\r\n\r\n    // Nested bullet point: - item or * item (without checkbox, indented)\r\n    const bulletMatch = line.match(/^(\\s+)[-*]\\s+(.+)$/);\r\n    if (bulletMatch && taskStack.length > 0) {\r\n      const indent = bulletMatch[1].length;\r\n      const text = bulletMatch[2].trim();\r\n\r\n      // Skip if it looks like a checkbox we didn't match\r\n      if (text.match(/^\\[[ xX]\\]/) || text.match(/^[☐☑✓✗]/)) {\r\n        continue;\r\n      }\r\n\r\n      const childTask: Task = {\r\n        text,\r\n        checked: false,\r\n        line: lineNumber,\r\n        children: [],\r\n        hasCheckbox: false\r\n      };\r\n\r\n      // Find appropriate parent based on indentation\r\n      while (taskStack.length > 1 && taskStack[taskStack.length - 1].indent >= indent) {\r\n        taskStack.pop();\r\n      }\r\n\r\n      if (taskStack.length > 0) {\r\n        taskStack[taskStack.length - 1].task.children.push(childTask);\r\n      }\r\n    }\r\n  }\r\n\r\n  return board;\r\n}\r\n","module.exports = require(\"vscode\");","export function toggleTaskInContent(content: string, line: number, checked: boolean): string {\r\n  // Detect line ending style\r\n  const lineEnding = content.includes('\\r\\n') ? '\\r\\n' : '\\n';\r\n  const lines = content.split(/\\r?\\n/);\r\n  const lineIndex = line - 1; // Convert to 0-indexed\r\n\r\n  if (lineIndex >= 0 && lineIndex < lines.length) {\r\n    const currentLine = lines[lineIndex];\r\n    if (checked) {\r\n      // Handle markdown checkboxes: - [ ] or * [ ]\r\n      let newLine = currentLine.replace(/([-*]\\s+)\\[ \\]/, '$1[x]');\r\n      // Handle unicode checkboxes: ☐ -> ☑\r\n      newLine = newLine.replace(/([-*]\\s+)☐/, '$1☑');\r\n      lines[lineIndex] = newLine;\r\n    } else {\r\n      // Handle markdown checkboxes: - [x] or * [x]\r\n      let newLine = currentLine.replace(/([-*]\\s+)\\[[xX]\\]/, '$1[ ]');\r\n      // Handle unicode checkboxes: ☑ or ✓ -> ☐\r\n      newLine = newLine.replace(/([-*]\\s+)[☑✓]/, '$1☐');\r\n      lines[lineIndex] = newLine;\r\n    }\r\n  }\r\n\r\n  return lines.join(lineEnding);\r\n}\r\n\r\nexport function moveTaskInContent(\r\n  content: string,\r\n  taskLine: number,\r\n  targetSectionTitle: string,\r\n  position: 'top' | 'bottom' | 'after' = 'bottom',\r\n  afterLine?: number\r\n): string {\r\n  // Detect line ending style\r\n  const lineEnding = content.includes('\\r\\n') ? '\\r\\n' : '\\n';\r\n  const lines = content.split(/\\r?\\n/);\r\n  const lineIndex = taskLine - 1;\r\n\r\n  // Find the task and all its children (indented lines below it)\r\n  const taskLines: string[] = [];\r\n  const taskIndent = lines[lineIndex]?.match(/^(\\s*)/)?.[1].length ?? 0;\r\n\r\n  // Add the task line\r\n  taskLines.push(lines[lineIndex]);\r\n\r\n  // Add all children (lines with greater indentation following the task)\r\n  let i = lineIndex + 1;\r\n  while (i < lines.length) {\r\n    const currentLine = lines[i];\r\n    const currentIndent = currentLine.match(/^(\\s*)/)?.[1].length ?? 0;\r\n\r\n    // Empty line or line with content at same/less indentation ends the block\r\n    if (currentLine.trim() === '') {\r\n      break;\r\n    }\r\n    if (currentIndent <= taskIndent && currentLine.trim() !== '') {\r\n      break;\r\n    }\r\n\r\n    taskLines.push(currentLine);\r\n    i++;\r\n  }\r\n\r\n  // De-indent the task block to become top-level\r\n  const deindentedLines = taskLines.map(line => {\r\n    if (line.startsWith(' '.repeat(taskIndent))) {\r\n      return line.slice(taskIndent);\r\n    }\r\n    return line;\r\n  });\r\n\r\n  // Remove the task block from original position\r\n  const beforeTask = lines.slice(0, lineIndex);\r\n  const afterTask = lines.slice(lineIndex + taskLines.length);\r\n  const newLines = [...beforeTask, ...afterTask];\r\n\r\n  // Find the target section and insert position\r\n  let targetInsertIndex = -1;\r\n\r\n  // If position is 'after', we need to find the line to insert after\r\n  // The afterLine was given in original line numbers, but we need to adjust for removed lines\r\n  let adjustedAfterLine = afterLine;\r\n  if (afterLine !== undefined && taskLine < afterLine) {\r\n    // Task was removed from before afterLine, so adjust\r\n    adjustedAfterLine = afterLine - taskLines.length;\r\n  }\r\n\r\n  for (let j = 0; j < newLines.length; j++) {\r\n    const sectionMatch = newLines[j].match(/^##\\s+(.+)$/);\r\n    if (sectionMatch) {\r\n      const sectionTitle = sectionMatch[1].trim();\r\n      if (sectionTitle === targetSectionTitle || sectionTitle.startsWith(targetSectionTitle)) {\r\n        if (position === 'top') {\r\n          // Insert right after the section header (skip empty lines)\r\n          let insertAfterHeader = j + 1;\r\n          while (insertAfterHeader < newLines.length && newLines[insertAfterHeader].trim() === '') {\r\n            insertAfterHeader++;\r\n          }\r\n          targetInsertIndex = insertAfterHeader;\r\n        } else if (position === 'after' && adjustedAfterLine !== undefined) {\r\n          // Find the task at adjustedAfterLine and insert after it and its children\r\n          const afterIndex = adjustedAfterLine - 1; // Convert to 0-indexed\r\n          if (afterIndex >= 0 && afterIndex < newLines.length) {\r\n            const afterTaskIndent = newLines[afterIndex]?.match(/^(\\s*)/)?.[1].length ?? 0;\r\n            let insertAfter = afterIndex + 1;\r\n            // Skip over children of the after task\r\n            while (insertAfter < newLines.length) {\r\n              const currentLine = newLines[insertAfter];\r\n              const currentIndent = currentLine.match(/^(\\s*)/)?.[1].length ?? 0;\r\n              if (currentLine.trim() === '' || currentIndent <= afterTaskIndent) {\r\n                break;\r\n              }\r\n              insertAfter++;\r\n            }\r\n            targetInsertIndex = insertAfter;\r\n          }\r\n        } else {\r\n          // 'bottom' - Find the end of this section\r\n          let endOfSection = j + 1;\r\n          while (endOfSection < newLines.length) {\r\n            if (newLines[endOfSection].match(/^##\\s+/)) {\r\n              break;\r\n            }\r\n            endOfSection++;\r\n          }\r\n          targetInsertIndex = endOfSection;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (targetInsertIndex === -1) {\r\n    // Target section not found, return unchanged\r\n    return content;\r\n  }\r\n\r\n  // Insert task lines at the target position\r\n  const result = [\r\n    ...newLines.slice(0, targetInsertIndex),\r\n    ...deindentedLines,\r\n    '',\r\n    ...newLines.slice(targetInsertIndex)\r\n  ];\r\n\r\n  // Clean up multiple consecutive empty lines\r\n  const cleaned: string[] = [];\r\n  let lastWasEmpty = false;\r\n  for (const resultLine of result) {\r\n    const isEmpty = resultLine.trim() === '';\r\n    if (isEmpty && lastWasEmpty) {\r\n      continue;\r\n    }\r\n    cleaned.push(resultLine);\r\n    lastWasEmpty = isEmpty;\r\n  }\r\n\r\n  return cleaned.join(lineEnding);\r\n}\r\n\r\nexport function moveTaskToParent(\r\n  content: string,\r\n  taskLine: number,\r\n  parentLine: number,\r\n  position: 'top' | 'bottom' | 'after' = 'bottom',\r\n  afterLine?: number\r\n): string {\r\n  // Detect line ending style\r\n  const lineEnding = content.includes('\\r\\n') ? '\\r\\n' : '\\n';\r\n  const lines = content.split(/\\r?\\n/);\r\n  const taskIndex = taskLine - 1;\r\n  const parentIndex = parentLine - 1;\r\n\r\n  // Get the task line content\r\n  const taskContent = lines[taskIndex];\r\n  if (!taskContent) {\r\n    return content;\r\n  }\r\n\r\n  // Extract task text (remove leading whitespace, bullet, and checkbox)\r\n  const taskMatch = taskContent.match(/^\\s*[-*]\\s+(\\[[ xX]\\]|[☐☑✓✗])?\\s*(.+)$/);\r\n  if (!taskMatch) {\r\n    return content;\r\n  }\r\n  const checkboxPart = taskMatch[1] || '[ ]';\r\n  const taskText = taskMatch[2];\r\n\r\n  // Get the parent's indentation level\r\n  const parentContent = lines[parentIndex];\r\n  if (!parentContent) {\r\n    return content;\r\n  }\r\n  const parentIndent = parentContent.match(/^(\\s*)/)?.[1].length ?? 0;\r\n  const childIndent = ' '.repeat(parentIndent + 2);\r\n\r\n  // Find all children of the task being moved (to move them too)\r\n  const taskLines: string[] = [];\r\n  const originalTaskIndent = taskContent.match(/^(\\s*)/)?.[1].length ?? 0;\r\n\r\n  // The task itself, re-indented as a child\r\n  taskLines.push(`${childIndent}- ${checkboxPart} ${taskText}`);\r\n\r\n  // Find and re-indent any children of the moved task\r\n  let i = taskIndex + 1;\r\n  while (i < lines.length) {\r\n    const currentLine = lines[i];\r\n    const currentIndent = currentLine.match(/^(\\s*)/)?.[1].length ?? 0;\r\n\r\n    if (currentLine.trim() === '') {\r\n      break;\r\n    }\r\n    if (currentIndent <= originalTaskIndent && currentLine.trim() !== '') {\r\n      break;\r\n    }\r\n\r\n    // Re-indent the child line\r\n    const childMatch = currentLine.match(/^(\\s*)(.+)$/);\r\n    if (childMatch) {\r\n      const relativeIndent = currentIndent - originalTaskIndent;\r\n      const newIndent = ' '.repeat(parentIndent + 2 + relativeIndent);\r\n      taskLines.push(`${newIndent}${childMatch[2]}`);\r\n    }\r\n    i++;\r\n  }\r\n\r\n  // Remove the task (and its children) from original position\r\n  const originalTaskBlockLength = i - taskIndex;\r\n\r\n  // Calculate adjusted parent index after removal\r\n  let adjustedParentIndex = parentIndex;\r\n  if (taskIndex < parentIndex) {\r\n    adjustedParentIndex = parentIndex - originalTaskBlockLength;\r\n  }\r\n\r\n  // Remove task block\r\n  const beforeTask = lines.slice(0, taskIndex);\r\n  const afterTask = lines.slice(taskIndex + originalTaskBlockLength);\r\n  const newLines = [...beforeTask, ...afterTask];\r\n\r\n  // Find insertion point - right after the parent or at end of parent's children\r\n  let insertIndex: number;\r\n  const adjustedParentContent = newLines[adjustedParentIndex];\r\n  const adjustedParentIndent = adjustedParentContent?.match(/^(\\s*)/)?.[1].length ?? 0;\r\n\r\n  if (position === 'top') {\r\n    // Insert right after parent line\r\n    insertIndex = adjustedParentIndex + 1;\r\n  } else if (position === 'after' && afterLine !== undefined) {\r\n    // Calculate adjusted afterLine\r\n    let adjustedAfterLine = afterLine;\r\n    if (taskIndex < afterLine) {\r\n      adjustedAfterLine = afterLine - originalTaskBlockLength;\r\n    }\r\n    const afterIndex = adjustedAfterLine - 1; // Convert to 0-indexed\r\n    if (afterIndex >= 0 && afterIndex < newLines.length) {\r\n      // Find end of the \"after\" task's children\r\n      const afterTaskIndent = newLines[afterIndex]?.match(/^(\\s*)/)?.[1].length ?? 0;\r\n      insertIndex = afterIndex + 1;\r\n      while (insertIndex < newLines.length) {\r\n        const currentLine = newLines[insertIndex];\r\n        const currentIndent = currentLine.match(/^(\\s*)/)?.[1].length ?? 0;\r\n        if (currentLine.trim() === '' || currentIndent <= afterTaskIndent) {\r\n          break;\r\n        }\r\n        insertIndex++;\r\n      }\r\n    } else {\r\n      // Fallback to end of parent's children\r\n      insertIndex = adjustedParentIndex + 1;\r\n    }\r\n  } else {\r\n    // 'bottom' - Find end of parent's children\r\n    insertIndex = adjustedParentIndex + 1;\r\n    while (insertIndex < newLines.length) {\r\n      const currentLine = newLines[insertIndex];\r\n      const currentIndent = currentLine.match(/^(\\s*)/)?.[1].length ?? 0;\r\n\r\n      if (currentLine.trim() === '') {\r\n        break;\r\n      }\r\n      if (currentIndent <= adjustedParentIndent) {\r\n        break;\r\n      }\r\n      insertIndex++;\r\n    }\r\n  }\r\n\r\n  // Insert the task lines\r\n  const result = [\r\n    ...newLines.slice(0, insertIndex),\r\n    ...taskLines,\r\n    ...newLines.slice(insertIndex)\r\n  ];\r\n\r\n  // Clean up multiple consecutive empty lines\r\n  const cleaned: string[] = [];\r\n  let lastWasEmpty = false;\r\n  for (const resultLine of result) {\r\n    const isEmpty = resultLine.trim() === '';\r\n    if (isEmpty && lastWasEmpty) {\r\n      continue;\r\n    }\r\n    cleaned.push(resultLine);\r\n    lastWasEmpty = isEmpty;\r\n  }\r\n\r\n  return cleaned.join(lineEnding);\r\n}\r\n\r\nexport function addTaskToSection(\r\n  content: string,\r\n  sectionTitle: string\r\n): { content: string; line: number } {\r\n  const lineEnding = content.includes('\\r\\n') ? '\\r\\n' : '\\n';\r\n  const lines = content.split(/\\r?\\n/);\r\n\r\n  // Find the section header\r\n  let sectionIndex = -1;\r\n  for (let i = 0; i < lines.length; i++) {\r\n    const match = lines[i].match(/^##\\s+(.+)$/);\r\n    if (match && match[1].trim() === sectionTitle) {\r\n      sectionIndex = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (sectionIndex === -1) {\r\n    return { content, line: -1 };\r\n  }\r\n\r\n  // Find insertion point (skip blank lines after header)\r\n  let insertIndex = sectionIndex + 1;\r\n  while (insertIndex < lines.length && lines[insertIndex].trim() === '') {\r\n    insertIndex++;\r\n  }\r\n\r\n  // Insert new task\r\n  const newTask = '- [ ] New task';\r\n  lines.splice(insertIndex, 0, newTask);\r\n\r\n  return {\r\n    content: lines.join(lineEnding),\r\n    line: insertIndex + 1 // 1-indexed\r\n  };\r\n}\r\n\r\nexport function editTaskTextInContent(\r\n  content: string,\r\n  line: number,\r\n  newText: string\r\n): string {\r\n  const lineEnding = content.includes('\\r\\n') ? '\\r\\n' : '\\n';\r\n  const lines = content.split(/\\r?\\n/);\r\n  const lineIndex = line - 1;\r\n\r\n  if (lineIndex < 0 || lineIndex >= lines.length) {\r\n    return content;\r\n  }\r\n\r\n  const currentLine = lines[lineIndex];\r\n\r\n  // Match markdown checkbox: - [ ] text or - [x] text\r\n  const mdMatch = currentLine.match(/^(\\s*[-*]\\s+\\[[ xX]\\]\\s+)(.+)$/);\r\n  if (mdMatch) {\r\n    lines[lineIndex] = mdMatch[1] + newText;\r\n    return lines.join(lineEnding);\r\n  }\r\n\r\n  // Match unicode checkbox: - ☐ text or - ☑ text\r\n  const unicodeMatch = currentLine.match(/^(\\s*[-*]\\s+[☐☑✓✗]\\s+)(.+)$/);\r\n  if (unicodeMatch) {\r\n    lines[lineIndex] = unicodeMatch[1] + newText;\r\n    return lines.join(lineEnding);\r\n  }\r\n\r\n  return content;\r\n}\r\n\r\nexport function addSubtaskToParent(\r\n  content: string,\r\n  parentLine: number\r\n): { content: string; line: number } {\r\n  const lineEnding = content.includes('\\r\\n') ? '\\r\\n' : '\\n';\r\n  const lines = content.split(/\\r?\\n/);\r\n  const parentIndex = parentLine - 1;\r\n\r\n  if (parentIndex < 0 || parentIndex >= lines.length) {\r\n    return { content, line: -1 };\r\n  }\r\n\r\n  const parentContent = lines[parentIndex];\r\n  const parentIndent = parentContent.match(/^(\\s*)/)?.[1].length ?? 0;\r\n  const childIndent = ' '.repeat(parentIndent + 2);\r\n\r\n  // Find insertion point: after parent and all its existing children\r\n  let insertIndex = parentIndex + 1;\r\n  while (insertIndex < lines.length) {\r\n    const currentLine = lines[insertIndex];\r\n    const currentIndent = currentLine.match(/^(\\s*)/)?.[1].length ?? 0;\r\n\r\n    if (currentLine.trim() === '') {\r\n      break;\r\n    }\r\n    if (currentIndent <= parentIndent) {\r\n      break;\r\n    }\r\n    insertIndex++;\r\n  }\r\n\r\n  // Insert new subtask\r\n  const newTask = `${childIndent}- [ ] New task`;\r\n  lines.splice(insertIndex, 0, newTask);\r\n\r\n  return {\r\n    content: lines.join(lineEnding),\r\n    line: insertIndex + 1 // 1-indexed\r\n  };\r\n}\r\n\r\nexport function removeCheckboxFromTask(\r\n  content: string,\r\n  line: number\r\n): string {\r\n  const lineEnding = content.includes('\\r\\n') ? '\\r\\n' : '\\n';\r\n  const lines = content.split(/\\r?\\n/);\r\n  const lineIndex = line - 1;\r\n\r\n  if (lineIndex < 0 || lineIndex >= lines.length) {\r\n    return content;\r\n  }\r\n\r\n  const currentLine = lines[lineIndex];\r\n\r\n  // Match markdown checkbox: - [ ] text or - [x] text and convert to - text\r\n  const mdMatch = currentLine.match(/^(\\s*[-*]\\s+)\\[[ xX]\\]\\s+(.+)$/);\r\n  if (mdMatch) {\r\n    lines[lineIndex] = mdMatch[1] + mdMatch[2];\r\n    return lines.join(lineEnding);\r\n  }\r\n\r\n  // Match unicode checkbox: - ☐ text or - ☑ text and convert to - text\r\n  const unicodeMatch = currentLine.match(/^(\\s*[-*]\\s+)[☐☑✓✗]\\s+(.+)$/);\r\n  if (unicodeMatch) {\r\n    lines[lineIndex] = unicodeMatch[1] + unicodeMatch[2];\r\n    return lines.join(lineEnding);\r\n  }\r\n\r\n  return content;\r\n}\r\n","import * as vscode from 'vscode';\r\nimport { parseMarkdown, Board, Task, Column } from './parser';\r\nimport { toggleTaskInContent, moveTaskInContent, moveTaskToParent, addTaskToSection, editTaskTextInContent, addSubtaskToParent } from './serializer';\r\n\r\nexport class KanbanViewProvider implements vscode.WebviewViewProvider {\r\n  public static readonly viewType = 'todoSidebar.kanbanView';\r\n\r\n  private _view?: vscode.WebviewView;\r\n  private _activeFileUri?: vscode.Uri;\r\n  private _board?: Board;\r\n  private _disposables: vscode.Disposable[] = [];\r\n  private _pendingEditLine?: number;\r\n\r\n  constructor(private readonly _context: vscode.ExtensionContext) {}\r\n\r\n  public resolveWebviewView(\r\n    webviewView: vscode.WebviewView,\r\n    _context: vscode.WebviewViewResolveContext,\r\n    _token: vscode.CancellationToken\r\n  ) {\r\n    this._view = webviewView;\r\n\r\n    webviewView.webview.options = {\r\n      enableScripts: true,\r\n      localResourceRoots: [this._context.extensionUri]\r\n    };\r\n\r\n    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);\r\n\r\n    // Handle messages from webview\r\n    webviewView.webview.onDidReceiveMessage(async (message) => {\r\n      switch (message.type) {\r\n        case 'toggle':\r\n          await this._handleToggle(message.line, message.checked, message.targetColumn);\r\n          break;\r\n        case 'move':\r\n          await this._handleMove(message.taskLine, message.targetSection, message.position, message.afterLine);\r\n          break;\r\n        case 'openAtLine':\r\n          await this._handleOpenAtLine(message.line);\r\n          break;\r\n        case 'getColumns':\r\n          // Send column list back to webview for the picker\r\n          if (this._board) {\r\n            this._view?.webview.postMessage({\r\n              type: 'columnsForPicker',\r\n              columns: this._board.columns.map(c => ({ title: c.title, isDoneColumn: c.isDoneColumn })),\r\n              taskLine: message.line\r\n            });\r\n          }\r\n          break;\r\n        case 'moveToParent':\r\n          await this._handleMoveToParent(message.taskLine, message.parentLine, message.position, message.afterLine);\r\n          break;\r\n        case 'addTask':\r\n          await this._handleAddTask(message.section);\r\n          break;\r\n        case 'editTaskText':\r\n          await this._handleEditTaskText(message.line, message.newText);\r\n          break;\r\n        case 'addSubtask':\r\n          await this._handleAddSubtask(message.parentLine);\r\n          break;\r\n      }\r\n    });\r\n\r\n    // Set up file watchers only once\r\n    if (this._disposables.length === 0) {\r\n      this._setupFileWatchers();\r\n    }\r\n\r\n    // Restore file: use existing activeFileUri or load from saved state\r\n    if (!this._activeFileUri) {\r\n      const savedPath = this._context.workspaceState.get<string>('todoSidebar.activeFile');\r\n      if (savedPath) {\r\n        try {\r\n          this._activeFileUri = vscode.Uri.file(savedPath);\r\n        } catch (e) {\r\n          console.error('Failed to restore saved file:', e);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Always refresh when view becomes visible\r\n    if (this._activeFileUri) {\r\n      this._refresh();\r\n    }\r\n  }\r\n\r\n  private _setupFileWatchers() {\r\n    // Watch for text document changes\r\n    this._disposables.push(\r\n      vscode.workspace.onDidChangeTextDocument((e) => {\r\n        if (this._activeFileUri && e.document.uri.toString() === this._activeFileUri.toString()) {\r\n          this._refresh();\r\n        }\r\n      })\r\n    );\r\n\r\n    // Watch for file system changes\r\n    const watcher = vscode.workspace.createFileSystemWatcher('**/*.md');\r\n    this._disposables.push(\r\n      watcher.onDidChange((uri) => {\r\n        if (this._activeFileUri && uri.toString() === this._activeFileUri.toString()) {\r\n          this._refresh();\r\n        }\r\n      })\r\n    );\r\n    this._disposables.push(watcher);\r\n  }\r\n\r\n  public async setActiveFile(uri: vscode.Uri) {\r\n    this._activeFileUri = uri;\r\n    // Store the fsPath for reliable restoration across sessions\r\n    await this._context.workspaceState.update('todoSidebar.activeFile', uri.fsPath);\r\n    await this._refresh();\r\n  }\r\n\r\n  public async refresh() {\r\n    await this._refresh();\r\n  }\r\n\r\n  private async _refresh() {\r\n    if (!this._activeFileUri || !this._view) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const content = await vscode.workspace.fs.readFile(this._activeFileUri);\r\n      const text = Buffer.from(content).toString('utf-8');\r\n      this._board = parseMarkdown(text);\r\n      const editLine = this._pendingEditLine;\r\n      this._pendingEditLine = undefined;\r\n      this._view.webview.postMessage({ type: 'update', board: this._board, editLine });\r\n    } catch (error) {\r\n      console.error('Error refreshing kanban board:', error);\r\n    }\r\n  }\r\n\r\n  private async _handleToggle(line: number, checked: boolean, targetColumn?: string) {\r\n    if (!this._activeFileUri || !this._board) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const content = await vscode.workspace.fs.readFile(this._activeFileUri);\r\n      let text = Buffer.from(content).toString('utf-8');\r\n\r\n      // Toggle the checkbox\r\n      text = toggleTaskInContent(text, line, checked);\r\n\r\n      // Only move top-level tasks to Done column (not subtasks)\r\n      const isTopLevel = this._isTopLevelTask(line);\r\n\r\n      if (checked && isTopLevel) {\r\n        // If checked and top-level, move to Done column at TOP\r\n        const doneColumn = this._board.columns.find((c) => c.isDoneColumn);\r\n        if (doneColumn) {\r\n          const currentColumn = this._findTaskColumn(line);\r\n          if (currentColumn && !currentColumn.isDoneColumn) {\r\n            text = moveTaskInContent(text, line, doneColumn.title, 'top');\r\n          }\r\n        }\r\n      } else if (targetColumn && isTopLevel) {\r\n        // If unchecked and a target column is specified, move there at TOP\r\n        text = moveTaskInContent(text, line, targetColumn, 'top');\r\n      }\r\n\r\n      await vscode.workspace.fs.writeFile(this._activeFileUri, Buffer.from(text, 'utf-8'));\r\n    } catch (error) {\r\n      console.error('Error toggling task:', error);\r\n    }\r\n  }\r\n\r\n  private _isTopLevelTask(line: number): boolean {\r\n    if (!this._board) {\r\n      return false;\r\n    }\r\n\r\n    for (const column of this._board.columns) {\r\n      for (const task of column.tasks) {\r\n        if (task.line === line) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private _findTaskColumn(line: number): Column | undefined {\r\n    if (!this._board) {\r\n      return undefined;\r\n    }\r\n\r\n    const findInTasks = (tasks: Task[]): boolean => {\r\n      for (const task of tasks) {\r\n        if (task.line === line) {\r\n          return true;\r\n        }\r\n        if (findInTasks(task.children)) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n\r\n    for (const column of this._board.columns) {\r\n      if (findInTasks(column.tasks)) {\r\n        return column;\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  private async _handleMove(taskLine: number, targetSection: string, position: 'top' | 'bottom' | 'after' = 'bottom', afterLine?: number) {\r\n    if (!this._activeFileUri) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const content = await vscode.workspace.fs.readFile(this._activeFileUri);\r\n      let text = Buffer.from(content).toString('utf-8');\r\n      text = moveTaskInContent(text, taskLine, targetSection, position, afterLine);\r\n      await vscode.workspace.fs.writeFile(this._activeFileUri, Buffer.from(text, 'utf-8'));\r\n    } catch (error) {\r\n      console.error('Error moving task:', error);\r\n    }\r\n  }\r\n\r\n  private async _handleMoveToParent(taskLine: number, parentLine: number, position: 'top' | 'bottom' | 'after' = 'bottom', afterLine?: number) {\r\n    if (!this._activeFileUri) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const content = await vscode.workspace.fs.readFile(this._activeFileUri);\r\n      let text = Buffer.from(content).toString('utf-8');\r\n      text = moveTaskToParent(text, taskLine, parentLine, position, afterLine);\r\n      await vscode.workspace.fs.writeFile(this._activeFileUri, Buffer.from(text, 'utf-8'));\r\n    } catch (error) {\r\n      console.error('Error moving task to parent:', error);\r\n    }\r\n  }\r\n\r\n  private async _handleOpenAtLine(line: number) {\r\n    if (!this._activeFileUri) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const document = await vscode.workspace.openTextDocument(this._activeFileUri);\r\n      const editor = await vscode.window.showTextDocument(document);\r\n      const position = new vscode.Position(line - 1, 0);\r\n      editor.selection = new vscode.Selection(position, position);\r\n      editor.revealRange(new vscode.Range(position, position), vscode.TextEditorRevealType.InCenter);\r\n    } catch (error) {\r\n      console.error('Error opening file at line:', error);\r\n    }\r\n  }\r\n\r\n  private async _handleAddTask(section: string) {\r\n    if (!this._activeFileUri) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const content = await vscode.workspace.fs.readFile(this._activeFileUri);\r\n      const text = Buffer.from(content).toString('utf-8');\r\n      const result = addTaskToSection(text, section);\r\n\r\n      if (result.line > 0) {\r\n        this._pendingEditLine = result.line;\r\n        await vscode.workspace.fs.writeFile(this._activeFileUri, Buffer.from(result.content, 'utf-8'));\r\n      }\r\n    } catch (error) {\r\n      console.error('Error adding task:', error);\r\n    }\r\n  }\r\n\r\n  private async _handleEditTaskText(line: number, newText: string) {\r\n    if (!this._activeFileUri) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const content = await vscode.workspace.fs.readFile(this._activeFileUri);\r\n      let text = Buffer.from(content).toString('utf-8');\r\n      text = editTaskTextInContent(text, line, newText);\r\n      await vscode.workspace.fs.writeFile(this._activeFileUri, Buffer.from(text, 'utf-8'));\r\n    } catch (error) {\r\n      console.error('Error editing task text:', error);\r\n    }\r\n  }\r\n\r\n  private async _handleAddSubtask(parentLine: number) {\r\n    if (!this._activeFileUri) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const content = await vscode.workspace.fs.readFile(this._activeFileUri);\r\n      const text = Buffer.from(content).toString('utf-8');\r\n      const result = addSubtaskToParent(text, parentLine);\r\n\r\n      if (result.line > 0) {\r\n        this._pendingEditLine = result.line;\r\n        await vscode.workspace.fs.writeFile(this._activeFileUri, Buffer.from(result.content, 'utf-8'));\r\n      }\r\n    } catch (error) {\r\n      console.error('Error adding subtask:', error);\r\n    }\r\n  }\r\n\r\n  private _getHtmlForWebview(webview: vscode.Webview): string {\r\n    const nonce = getNonce();\r\n\r\n    return `<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; script-src 'nonce-${nonce}' https://cdn.jsdelivr.net;\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  <title>Kanban Board</title>\r\n  <script src=\"https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js\"></script>\r\n  <style>\r\n    body {\r\n      padding: 8px;\r\n      font-family: var(--vscode-font-family);\r\n      font-size: var(--vscode-font-size);\r\n      color: var(--vscode-foreground);\r\n      background: var(--vscode-sideBar-background);\r\n    }\r\n    .no-file {\r\n      text-align: center;\r\n      padding: 20px;\r\n      color: var(--vscode-descriptionForeground);\r\n    }\r\n    .board {\r\n      display: flex;\r\n      flex-direction: column;\r\n      gap: 16px;\r\n    }\r\n    .board-header {\r\n      margin-bottom: 8px;\r\n    }\r\n    .board-title {\r\n      font-size: 1.2em;\r\n      font-weight: bold;\r\n      margin: 0 0 4px 0;\r\n    }\r\n    .board-description {\r\n      font-size: 0.9em;\r\n      color: var(--vscode-descriptionForeground);\r\n      margin: 0;\r\n    }\r\n    .column {\r\n      background: var(--vscode-editor-background);\r\n      border: 1px solid var(--vscode-panel-border);\r\n      border-radius: 4px;\r\n      padding: 8px;\r\n    }\r\n    .column-header {\r\n      display: flex;\r\n      justify-content: space-between;\r\n      align-items: center;\r\n      font-weight: bold;\r\n      margin-bottom: 8px;\r\n      padding-bottom: 4px;\r\n      border-bottom: 1px solid var(--vscode-panel-border);\r\n    }\r\n    .add-task-btn {\r\n      background: none;\r\n      border: none;\r\n      color: var(--vscode-foreground);\r\n      cursor: pointer;\r\n      font-size: 1.2em;\r\n      opacity: 0.5;\r\n      padding: 0 4px;\r\n      line-height: 1;\r\n    }\r\n    .add-task-btn:hover {\r\n      opacity: 1;\r\n    }\r\n    .task-edit-input {\r\n      flex: 1;\r\n      background: var(--vscode-input-background);\r\n      border: 1px solid var(--vscode-focusBorder);\r\n      color: var(--vscode-foreground);\r\n      font-family: inherit;\r\n      font-size: inherit;\r\n      padding: 2px 4px;\r\n      border-radius: 2px;\r\n      min-width: 0;\r\n    }\r\n    .task-edit-input:focus {\r\n      outline: none;\r\n      border-color: var(--vscode-focusBorder);\r\n    }\r\n    .column.drag-over {\r\n      background: var(--vscode-list-hoverBackground);\r\n    }\r\n    .task {\r\n      background: var(--vscode-input-background);\r\n      border: 1px solid var(--vscode-input-border);\r\n      border-radius: 3px;\r\n      padding: 6px 8px;\r\n      margin-bottom: 6px;\r\n      cursor: grab;\r\n    }\r\n    .task:last-child {\r\n      margin-bottom: 0;\r\n    }\r\n    .task.dragging {\r\n      opacity: 0.5;\r\n    }\r\n    .task-header {\r\n      display: flex;\r\n      align-items: flex-start;\r\n      gap: 6px;\r\n    }\r\n    .task-checkbox {\r\n      margin-top: 2px;\r\n      cursor: pointer;\r\n    }\r\n    .task-text {\r\n      flex: 1;\r\n      word-break: break-word;\r\n    }\r\n    .task-text.checked {\r\n      text-decoration: line-through;\r\n      opacity: 0.7;\r\n    }\r\n    .task-actions {\r\n      display: flex;\r\n      flex-shrink: 0;\r\n      gap: 2px;\r\n    }\r\n    .open-btn, .add-subtask-btn {\r\n      background: none;\r\n      border: none;\r\n      color: var(--vscode-textLink-foreground);\r\n      cursor: pointer;\r\n      padding: 2px 4px;\r\n      font-size: 14px;\r\n      line-height: 1;\r\n      opacity: 0.7;\r\n    }\r\n    .open-btn:hover, .add-subtask-btn:hover {\r\n      opacity: 1;\r\n    }\r\n    .children {\r\n      margin-left: 20px;\r\n      margin-top: 4px;\r\n      min-height: 10px;\r\n      font-size: 0.9em;\r\n      color: var(--vscode-descriptionForeground);\r\n    }\r\n    .child-task {\r\n      background: var(--vscode-input-background);\r\n      border: 1px solid var(--vscode-input-border);\r\n      border-radius: 3px;\r\n      padding: 4px 6px;\r\n      margin: 4px 0;\r\n      cursor: grab;\r\n      font-size: 0.9em;\r\n    }\r\n    .child-task .task-header {\r\n      display: flex;\r\n      align-items: flex-start;\r\n      gap: 4px;\r\n    }\r\n    .child-task .task-checkbox {\r\n      margin-top: 1px;\r\n    }\r\n    .child-task .open-btn {\r\n      font-size: 0.8em;\r\n      padding: 1px 3px;\r\n    }\r\n    .child-task.task-ghost {\r\n      opacity: 0.4;\r\n      background: var(--vscode-list-activeSelectionBackground);\r\n      border: 2px dashed var(--vscode-focusBorder);\r\n    }\r\n    /* SortableJS styles */\r\n    .task-ghost {\r\n      opacity: 0.4;\r\n      background: var(--vscode-list-activeSelectionBackground);\r\n      border: 2px dashed var(--vscode-focusBorder);\r\n    }\r\n    .task-chosen {\r\n      background: var(--vscode-list-activeSelectionBackground);\r\n      border-color: var(--vscode-focusBorder);\r\n    }\r\n    .task-drag {\r\n      opacity: 1;\r\n      background: var(--vscode-list-activeSelectionBackground);\r\n    }\r\n    .tasks {\r\n      min-height: 20px;\r\n    }\r\n    .sortable-placeholder {\r\n      height: 40px;\r\n      background: var(--vscode-list-hoverBackground);\r\n      border: 2px dashed var(--vscode-focusBorder);\r\n      border-radius: 3px;\r\n      margin-bottom: 6px;\r\n    }\r\n    /* Column picker modal */\r\n    .column-picker-overlay {\r\n      position: fixed;\r\n      top: 0;\r\n      left: 0;\r\n      right: 0;\r\n      bottom: 0;\r\n      background: rgba(0, 0, 0, 0.5);\r\n      display: flex;\r\n      align-items: center;\r\n      justify-content: center;\r\n      z-index: 1000;\r\n    }\r\n    .column-picker {\r\n      background: var(--vscode-editor-background);\r\n      border: 1px solid var(--vscode-panel-border);\r\n      border-radius: 6px;\r\n      padding: 12px;\r\n      min-width: 200px;\r\n      max-width: 300px;\r\n    }\r\n    .column-picker-title {\r\n      font-weight: bold;\r\n      margin-bottom: 10px;\r\n      padding-bottom: 8px;\r\n      border-bottom: 1px solid var(--vscode-panel-border);\r\n    }\r\n    .column-picker-option {\r\n      display: block;\r\n      width: 100%;\r\n      padding: 8px 12px;\r\n      margin: 4px 0;\r\n      background: var(--vscode-input-background);\r\n      border: 1px solid var(--vscode-input-border);\r\n      border-radius: 3px;\r\n      color: var(--vscode-foreground);\r\n      cursor: pointer;\r\n      text-align: left;\r\n    }\r\n    .column-picker-option:hover {\r\n      background: var(--vscode-list-hoverBackground);\r\n      border-color: var(--vscode-focusBorder);\r\n    }\r\n    .column-picker-cancel {\r\n      display: block;\r\n      width: 100%;\r\n      padding: 8px 12px;\r\n      margin-top: 8px;\r\n      background: transparent;\r\n      border: 1px solid var(--vscode-input-border);\r\n      border-radius: 3px;\r\n      color: var(--vscode-descriptionForeground);\r\n      cursor: pointer;\r\n      text-align: center;\r\n    }\r\n    .column-picker-cancel:hover {\r\n      background: var(--vscode-list-hoverBackground);\r\n    }\r\n  </style>\r\n</head>\r\n<body>\r\n  <div id=\"content\">\r\n    <div class=\"no-file\">\r\n      Open a markdown file to view your todo board.<br>\r\n      Use the command \"Todo Sidebar: Open Markdown File\"\r\n    </div>\r\n  </div>\r\n\r\n  <script nonce=\"${nonce}\">\r\n    const vscode = acquireVsCodeApi();\r\n    let board = null;\r\n\r\n    function renderChildTask(child, isDoneColumn) {\r\n      const grandchildren = child.children.map(c => renderChildTask(c, isDoneColumn)).join('');\r\n      return \\`\r\n        <div class=\"child-task\" draggable=\"true\" data-line=\"\\${child.line}\" data-in-done=\"\\${isDoneColumn}\">\r\n          <div class=\"task-header\">\r\n            <input type=\"checkbox\" class=\"task-checkbox\" \\${child.checked ? 'checked' : ''} data-line=\"\\${child.line}\" data-in-done=\"\\${isDoneColumn}\">\r\n            <span class=\"task-text \\${child.checked ? 'checked' : ''}\">\\${escapeHtml(child.text)}</span>\r\n            <div class=\"task-actions\">\r\n              <button class=\"add-subtask-btn\" data-line=\"\\${child.line}\" title=\"Add subtask\">+</button>\r\n              <button class=\"open-btn\" data-line=\"\\${child.line}\" title=\"Open in editor\">↗</button>\r\n            </div>\r\n          </div>\r\n          \\${grandchildren ? '<div class=\"children\" data-parent-line=\"' + child.line + '\">' + grandchildren + '</div>' : ''}\r\n        </div>\r\n      \\`;\r\n    }\r\n\r\n    function renderTask(task, isDoneColumn = false) {\r\n      const children = task.children.map(child => renderChildTask(child, isDoneColumn)).join('');\r\n\r\n      return \\`\r\n        <div class=\"task\" draggable=\"true\" data-line=\"\\${task.line}\" data-in-done=\"\\${isDoneColumn}\">\r\n          <div class=\"task-header\">\r\n            <input type=\"checkbox\" class=\"task-checkbox\" \\${task.checked ? 'checked' : ''} data-line=\"\\${task.line}\" data-in-done=\"\\${isDoneColumn}\">\r\n            <span class=\"task-text \\${task.checked ? 'checked' : ''}\">\\${escapeHtml(task.text)}</span>\r\n            <div class=\"task-actions\">\r\n              <button class=\"add-subtask-btn\" data-line=\"\\${task.line}\" title=\"Add subtask\">+</button>\r\n              <button class=\"open-btn\" data-line=\"\\${task.line}\" title=\"Open in editor\">↗</button>\r\n            </div>\r\n          </div>\r\n          <div class=\"children\" data-parent-line=\"\\${task.line}\">\\${children}</div>\r\n        </div>\r\n      \\`;\r\n    }\r\n\r\n    function renderColumn(column) {\r\n      const tasks = column.tasks.map(task => renderTask(task, column.isDoneColumn)).join('');\r\n      return \\`\r\n        <div class=\"column\" data-section=\"\\${escapeHtml(column.title)}\" data-is-done=\"\\${column.isDoneColumn}\">\r\n          <div class=\"column-header\">\r\n            <span class=\"column-title\">\\${escapeHtml(column.title)}</span>\r\n            <button class=\"add-task-btn\" data-section=\"\\${escapeHtml(column.title)}\" title=\"Add task\">+</button>\r\n          </div>\r\n          <div class=\"tasks\" data-section=\"\\${escapeHtml(column.title)}\">\\${tasks}</div>\r\n        </div>\r\n      \\`;\r\n    }\r\n\r\n    function renderBoard(board) {\r\n      if (!board || !board.columns || board.columns.length === 0) {\r\n        return '<div class=\"no-file\">No columns found in the markdown file.</div>';\r\n      }\r\n\r\n      const columns = board.columns.map(col => renderColumn(col)).join('');\r\n      return \\`\r\n        <div class=\"board-header\">\r\n          \\${board.title ? '<h2 class=\"board-title\">' + escapeHtml(board.title) + '</h2>' : ''}\r\n          \\${board.description ? '<p class=\"board-description\">' + escapeHtml(board.description) + '</p>' : ''}\r\n        </div>\r\n        <div class=\"board\">\\${columns}</div>\r\n      \\`;\r\n    }\r\n\r\n    function escapeHtml(text) {\r\n      const div = document.createElement('div');\r\n      div.textContent = text;\r\n      return div.innerHTML;\r\n    }\r\n\r\n    function updateUI() {\r\n      document.getElementById('content').innerHTML = renderBoard(board);\r\n      setupEventListeners();\r\n    }\r\n\r\n    function showColumnPicker(columns, taskLine) {\r\n      // Filter out the Done column - user shouldn't move back to Done\r\n      const availableColumns = columns.filter(c => !c.isDoneColumn);\r\n\r\n      const overlay = document.createElement('div');\r\n      overlay.className = 'column-picker-overlay';\r\n      overlay.innerHTML = \\`\r\n        <div class=\"column-picker\">\r\n          <div class=\"column-picker-title\">Move task to:</div>\r\n          \\${availableColumns.map(c => \\`\r\n            <button class=\"column-picker-option\" data-column=\"\\${escapeHtml(c.title)}\">\\${escapeHtml(c.title)}</button>\r\n          \\`).join('')}\r\n          <button class=\"column-picker-cancel\">Cancel</button>\r\n        </div>\r\n      \\`;\r\n\r\n      overlay.addEventListener('click', (e) => {\r\n        if (e.target.classList.contains('column-picker-option')) {\r\n          const targetColumn = e.target.dataset.column;\r\n          vscode.postMessage({ type: 'toggle', line: taskLine, checked: false, targetColumn });\r\n          overlay.remove();\r\n        } else if (e.target.classList.contains('column-picker-cancel') || e.target === overlay) {\r\n          // Cancel - revert the checkbox\r\n          const checkbox = document.querySelector(\\`.task-checkbox[data-line=\"\\${taskLine}\"]\\`);\r\n          if (checkbox) checkbox.checked = true;\r\n          overlay.remove();\r\n        }\r\n      });\r\n\r\n      document.body.appendChild(overlay);\r\n    }\r\n\r\n    function enterEditMode(taskElement) {\r\n      const textSpan = taskElement.querySelector('.task-text');\r\n      if (!textSpan || taskElement.querySelector('.task-edit-input')) {\r\n        return; // Already in edit mode\r\n      }\r\n\r\n      const line = parseInt(taskElement.dataset.line);\r\n      const originalText = textSpan.textContent;\r\n\r\n      const input = document.createElement('input');\r\n      input.type = 'text';\r\n      input.className = 'task-edit-input';\r\n      input.value = originalText;\r\n      input.dataset.line = line;\r\n      input.dataset.originalText = originalText;\r\n\r\n      textSpan.replaceWith(input);\r\n      input.focus();\r\n      input.select();\r\n\r\n      input.addEventListener('keydown', handleEditKeydown);\r\n      input.addEventListener('blur', handleEditBlur);\r\n    }\r\n\r\n    function handleEditKeydown(e) {\r\n      if (e.key === 'Enter') {\r\n        e.preventDefault();\r\n        saveEdit(e.target);\r\n      } else if (e.key === 'Escape') {\r\n        e.preventDefault();\r\n        cancelEdit(e.target);\r\n      }\r\n    }\r\n\r\n    function handleEditBlur(e) {\r\n      // Small delay to allow cancel via Escape\r\n      setTimeout(() => {\r\n        if (document.body.contains(e.target)) {\r\n          saveEdit(e.target);\r\n        }\r\n      }, 0);\r\n    }\r\n\r\n    function saveEdit(input) {\r\n      const line = parseInt(input.dataset.line);\r\n      const newText = input.value.trim();\r\n      const originalText = input.dataset.originalText;\r\n\r\n      if (newText && newText !== originalText) {\r\n        vscode.postMessage({ type: 'editTaskText', line, newText });\r\n      }\r\n      // Restore span (UI will fully refresh from file watcher)\r\n      restoreTextSpan(input, newText || originalText);\r\n    }\r\n\r\n    function cancelEdit(input) {\r\n      const originalText = input.dataset.originalText;\r\n      restoreTextSpan(input, originalText);\r\n    }\r\n\r\n    function restoreTextSpan(input, text) {\r\n      const span = document.createElement('span');\r\n      span.className = 'task-text';\r\n      span.textContent = text;\r\n      input.replaceWith(span);\r\n    }\r\n\r\n    function setupEventListeners() {\r\n      // Checkboxes\r\n      document.querySelectorAll('.task-checkbox').forEach(checkbox => {\r\n        checkbox.addEventListener('change', (e) => {\r\n          const line = parseInt(e.target.dataset.line);\r\n          const checked = e.target.checked;\r\n          const inDone = e.target.dataset.inDone === 'true';\r\n\r\n          if (!checked && inDone) {\r\n            // Unchecking in Done column - show column picker\r\n            pendingUncheckLine = line;\r\n            vscode.postMessage({ type: 'getColumns', line });\r\n          } else {\r\n            // Normal toggle\r\n            vscode.postMessage({ type: 'toggle', line, checked });\r\n          }\r\n        });\r\n      });\r\n\r\n      // Open buttons\r\n      document.querySelectorAll('.open-btn').forEach(btn => {\r\n        btn.addEventListener('click', (e) => {\r\n          const line = parseInt(e.target.dataset.line);\r\n          vscode.postMessage({ type: 'openAtLine', line });\r\n        });\r\n      });\r\n\r\n      // Add task buttons\r\n      document.querySelectorAll('.add-task-btn').forEach(btn => {\r\n        btn.addEventListener('click', (e) => {\r\n          e.stopPropagation();\r\n          const section = e.target.dataset.section;\r\n          vscode.postMessage({ type: 'addTask', section });\r\n        });\r\n      });\r\n\r\n      // Add subtask buttons\r\n      document.querySelectorAll('.add-subtask-btn').forEach(btn => {\r\n        btn.addEventListener('click', (e) => {\r\n          e.stopPropagation();\r\n          const parentLine = parseInt(e.target.dataset.line);\r\n          vscode.postMessage({ type: 'addSubtask', parentLine });\r\n        });\r\n      });\r\n\r\n      // Double-click to edit - listen on task container, not just text\r\n      document.querySelectorAll('.task, .child-task').forEach(taskElement => {\r\n        taskElement.addEventListener('dblclick', (e) => {\r\n          // Don't trigger if clicking on buttons or checkbox\r\n          if (e.target.closest('button, input')) {\r\n            return;\r\n          }\r\n          e.stopPropagation();\r\n          enterEditMode(taskElement);\r\n        });\r\n      });\r\n\r\n      // SortableJS for column-level tasks\r\n      document.querySelectorAll('.tasks').forEach(taskList => {\r\n        new Sortable(taskList, {\r\n          group: 'shared',\r\n          animation: 150,\r\n          ghostClass: 'task-ghost',\r\n          chosenClass: 'task-chosen',\r\n          dragClass: 'task-drag',\r\n          onEnd: (evt) => {\r\n            const taskLine = parseInt(evt.item.dataset.line);\r\n            const targetSection = evt.to.dataset.section;\r\n            const targetParentLine = evt.to.dataset.parentLine;\r\n            const newIndex = evt.newIndex;\r\n\r\n            if (targetParentLine) {\r\n              // Dropped into a parent task's children area\r\n              const prevSibling = evt.item.previousElementSibling;\r\n              const afterLine = prevSibling ? parseInt(prevSibling.dataset.line) : undefined;\r\n              vscode.postMessage({\r\n                type: 'moveToParent',\r\n                taskLine,\r\n                parentLine: parseInt(targetParentLine),\r\n                position: newIndex === 0 ? 'top' : 'after',\r\n                afterLine\r\n              });\r\n            } else if (targetSection) {\r\n              // Dropped into a column - find what we're after\r\n              const prevSibling = evt.item.previousElementSibling;\r\n              if (newIndex === 0 || !prevSibling) {\r\n                vscode.postMessage({ type: 'move', taskLine, targetSection, position: 'top' });\r\n              } else {\r\n                const afterLine = parseInt(prevSibling.dataset.line);\r\n                vscode.postMessage({ type: 'move', taskLine, targetSection, position: 'after', afterLine });\r\n              }\r\n            }\r\n          }\r\n        });\r\n      });\r\n\r\n      // SortableJS for child tasks within parent tasks\r\n      document.querySelectorAll('.children').forEach(childList => {\r\n        new Sortable(childList, {\r\n          group: 'shared',\r\n          animation: 150,\r\n          ghostClass: 'task-ghost',\r\n          chosenClass: 'task-chosen',\r\n          dragClass: 'task-drag',\r\n          onEnd: (evt) => {\r\n            const taskLine = parseInt(evt.item.dataset.line);\r\n            const targetSection = evt.to.dataset.section;\r\n            const targetParentLine = evt.to.dataset.parentLine;\r\n            const newIndex = evt.newIndex;\r\n\r\n            if (targetParentLine) {\r\n              // Dropped into a parent task's children area\r\n              const prevSibling = evt.item.previousElementSibling;\r\n              const afterLine = prevSibling ? parseInt(prevSibling.dataset.line) : undefined;\r\n              vscode.postMessage({\r\n                type: 'moveToParent',\r\n                taskLine,\r\n                parentLine: parseInt(targetParentLine),\r\n                position: newIndex === 0 ? 'top' : 'after',\r\n                afterLine\r\n              });\r\n            } else if (targetSection) {\r\n              // Promoted to column level (dragged out of parent)\r\n              const prevSibling = evt.item.previousElementSibling;\r\n              if (newIndex === 0 || !prevSibling) {\r\n                vscode.postMessage({ type: 'move', taskLine, targetSection, position: 'top' });\r\n              } else {\r\n                const afterLine = parseInt(prevSibling.dataset.line);\r\n                vscode.postMessage({ type: 'move', taskLine, targetSection, position: 'after', afterLine });\r\n              }\r\n            }\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    // Handle messages from extension\r\n    window.addEventListener('message', (event) => {\r\n      const message = event.data;\r\n      if (message.type === 'update') {\r\n        board = message.board;\r\n        updateUI();\r\n        // Enter edit mode on newly added task if specified\r\n        if (message.editLine) {\r\n          const taskElement = document.querySelector(\\`[data-line=\"\\${message.editLine}\"]\\`);\r\n          if (taskElement) {\r\n            enterEditMode(taskElement);\r\n          }\r\n        }\r\n      } else if (message.type === 'columnsForPicker') {\r\n        showColumnPicker(message.columns, message.taskLine);\r\n      }\r\n    });\r\n  </script>\r\n</body>\r\n</html>`;\r\n  }\r\n\r\n  public dispose() {\r\n    for (const disposable of this._disposables) {\r\n      disposable.dispose();\r\n    }\r\n  }\r\n}\r\n\r\nfunction getNonce() {\r\n  let text = '';\r\n  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n  for (let i = 0; i < 32; i++) {\r\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\r\n  }\r\n  return text;\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["context","console","log","kanbanProvider","KanbanViewProvider","subscriptions","push","vscode","window","registerWebviewViewProvider","viewType","openFileCommand","commands","registerCommand","async","fileUri","showOpenDialog","canSelectFiles","canSelectFolders","canSelectMany","filters","title","setActiveFile","showInformationMessage","fsPath","refreshCommand","refresh","dispose","content","lines","replace","split","board","description","columns","currentColumn","taskStack","foundFirstColumn","i","length","line","lineNumber","titleMatch","match","trim","descMatch","columnMatch","isDoneColumn","toLowerCase","includes","tasks","taskMatch","indent","checked","task","text","children","hasCheckbox","pop","unicodeTaskMatch","checkChar","nestedQuoteMatch","childTask","bulletMatch","module","exports","require","lineEnding","lineIndex","currentLine","newLine","join","taskLine","targetSectionTitle","position","afterLine","taskLines","taskIndent","currentIndent","deindentedLines","map","startsWith","repeat","slice","newLines","targetInsertIndex","adjustedAfterLine","undefined","j","sectionMatch","sectionTitle","insertAfterHeader","afterIndex","afterTaskIndent","insertAfter","endOfSection","result","cleaned","lastWasEmpty","resultLine","isEmpty","parentLine","taskIndex","parentIndex","taskContent","checkboxPart","taskText","parentContent","parentIndent","childIndent","originalTaskIndent","childMatch","newIndent","originalTaskBlockLength","adjustedParentIndex","insertIndex","adjustedParentContent","adjustedParentIndent","sectionIndex","splice","newText","mdMatch","unicodeMatch","newTask","_context","static","_view","_activeFileUri","_board","_disposables","_pendingEditLine","constructor","resolveWebviewView","webviewView","_token","this","webview","options","enableScripts","localResourceRoots","extensionUri","html","_getHtmlForWebview","onDidReceiveMessage","message","type","_handleToggle","targetColumn","_handleMove","targetSection","_handleOpenAtLine","postMessage","c","_handleMoveToParent","_handleAddTask","section","_handleEditTaskText","_handleAddSubtask","_setupFileWatchers","savedPath","workspaceState","get","Uri","file","e","error","_refresh","workspace","onDidChangeTextDocument","document","uri","toString","watcher","createFileSystemWatcher","onDidChange","update","fs","readFile","Buffer","from","parseMarkdown","editLine","toggleTaskInContent","isTopLevel","_isTopLevelTask","doneColumn","find","_findTaskColumn","moveTaskInContent","writeFile","column","findInTasks","moveTaskToParent","openTextDocument","editor","showTextDocument","Position","selection","Selection","revealRange","Range","TextEditorRevealType","InCenter","addTaskToSection","editTaskTextInContent","addSubtaskToParent","nonce","possible","charAt","Math","floor","random","getNonce","cspSource","disposable","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"ignoreList":[],"sourceRoot":""}